"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[72157],{61655:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"rails/debugging/expert/binding_of_caller_usage","title":"binding_of_caller_usage","description":"\ud83d\udd17 Binding of Caller for Stack Frame Inspection","source":"@site/docs/rails/debugging/expert/binding_of_caller_usage.md","sourceDirName":"rails/debugging/expert","slug":"/rails/debugging/expert/binding_of_caller_usage","permalink":"/keep-being-human-dev/docs/rails/debugging/expert/binding_of_caller_usage","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/debugging/expert/binding_of_caller_usage.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"view_dev_logs","permalink":"/keep-being-human-dev/docs/rails/debugging/beginner/view_dev_logs"},"next":{"title":"byebug_advanced_mastery","permalink":"/keep-being-human-dev/docs/rails/debugging/expert/byebug_advanced_mastery"}}');var r=a(23420),t=a(65404);const l={},s=void 0,o={},c=[{value:"\ud83d\udd17 Binding of Caller for Stack Frame Inspection",id:"-binding-of-caller-for-stack-frame-inspection",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"-binding-of-caller-for-stack-frame-inspection",children:"\ud83d\udd17 Binding of Caller for Stack Frame Inspection"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"binding_of_caller"})," gem to access and inspect bindings up the call stack. This allows you to peek into local variables and state deep within utility methods or Rails internals without rewriting your code to pass context manually."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"# Gemfile\ngem 'binding_of_caller'\n\n# Somewhere deep inside a helper or library method\ndef deep_compute(a, b)\n  # Capture the binding two frames up\n  caller_binding = binding.of_caller(2)\n  caller_locals = caller_binding.local_variables.map { |var| [var, caller_binding.local_variable_get(var)] }\n  Rails.logger.debug(\"Caller locals: \")\n  Rails.logger.debug(caller_locals.inspect)\n  a + b\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can also use this within a byebug session to modify local variables of a previous frame:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"(byebug) frame 3\n(byebug) eval local_var = 'new value'\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method gives you unprecedented visibility into the inner workings of your Rails stack."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>s});var i=a(36672);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);