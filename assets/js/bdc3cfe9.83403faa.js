"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[58398],{65404:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(36672);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},86112:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"ruby/symbols/expert/secure_dynamic_symbol_creation","title":"secure_dynamic_symbol_creation","description":"\ud83d\udd12 Secure Dynamic Symbol Handling","source":"@site/docs/ruby/symbols/expert/secure_dynamic_symbol_creation.md","sourceDirName":"ruby/symbols/expert","slug":"/ruby/symbols/expert/secure_dynamic_symbol_creation","permalink":"/keep-being-human-dev/docs/ruby/symbols/expert/secure_dynamic_symbol_creation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/symbols/expert/secure_dynamic_symbol_creation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"dsl_metaprogramming_with_symbols","permalink":"/keep-being-human-dev/docs/ruby/symbols/expert/dsl_metaprogramming_with_symbols"},"next":{"title":"symbol_garbage_collection_inspection","permalink":"/keep-being-human-dev/docs/ruby/symbols/expert/symbol_garbage_collection_inspection"}}');var o=s(23420),r=s(65404);const a={},i=void 0,c={},l=[{value:"\ud83d\udd12 Secure Dynamic Symbol Handling",id:"-secure-dynamic-symbol-handling",level:2}];function m(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"-secure-dynamic-symbol-handling",children:"\ud83d\udd12 Secure Dynamic Symbol Handling"}),"\n",(0,o.jsx)(n.p,{children:"Converting untrusted user input to symbols can open symbol table injection vulnerabilities (symbols never get freed before Ruby\xa02.2). Always whitelist or memoize allowed values to prevent an attacker from exhausting memory with unique symbols."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:'ALLOWED_EVENTS = %i[create update destroy].freeze\n\ndef safe_event_to_sym(event)\n  sym = event.to_s.strip.downcase.to_sym\n  raise "Invalid event" unless ALLOWED_EVENTS.include?(sym)\n  sym\nend\n\n# Usage\nuser_input = params[:event]\nevent = safe_event_to_sym(user_input)\nhandle_#{event}(resource)\n'})}),"\n",(0,o.jsx)(n.p,{children:"For dynamic sets, use a reusable symbol pool (Hash mapping strings to symbols) with a maximum size, evicting old entries to keep the symbol table bounded."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}}}]);