"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[94881],{58634:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>n,toc:()=>p});const n=JSON.parse('{"id":"rails/deployment/advanced/capistrano_parallel_precompile","title":"capistrano_parallel_precompile","description":"\u2699\ufe0f Speed Up Asset Precompilation with Parallel Capistrano Tasks","source":"@site/docs/rails/deployment/advanced/capistrano_parallel_precompile.md","sourceDirName":"rails/deployment/advanced","slug":"/rails/deployment/advanced/capistrano_parallel_precompile","permalink":"/keep-being-human-dev/docs/rails/deployment/advanced/capistrano_parallel_precompile","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/deployment/advanced/capistrano_parallel_precompile.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"web_console_error_pages","permalink":"/keep-being-human-dev/docs/rails/debugging/middle/web_console_error_pages"},"next":{"title":"k8s_canary_deployment","permalink":"/keep-being-human-dev/docs/rails/deployment/advanced/k8s_canary_deployment"}}');var t=s(23420),r=s(65404);const l={},o=void 0,i={},p=[{value:"\u2699\ufe0f Speed Up Asset Precompilation with Parallel Capistrano Tasks",id:"\ufe0f-speed-up-asset-precompilation-with-parallel-capistrano-tasks",level:2}];function c(e){const a={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.h2,{id:"\ufe0f-speed-up-asset-precompilation-with-parallel-capistrano-tasks",children:"\u2699\ufe0f Speed Up Asset Precompilation with Parallel Capistrano Tasks"}),"\n",(0,t.jsx)(a.p,{children:"Compiling assets sequentially on a single server can become a bottleneck. You can distribute Rails asset precompilation across multiple app servers by using SSHKit\u2019s concurrency along with Capistrano tasks. This reduces deploy time significantly for large asset pipelines."}),"\n",(0,t.jsx)(a.p,{children:"Add this task to your Capistrano config:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-ruby",children:"# lib/capistrano/tasks/parallel_assets.rake\nnamespace :deploy do\n  desc 'Compile assets in parallel on app servers'\n  task :parallel_assets do\n    on roles(:web), in: :groups, limit: 3, wait: 5 do |host|\n      within release_path do\n        with rails_env: fetch(:rails_env) do\n          execute :bundle, :exec, :rake, 'assets:precompile'\n        end\n      end\n    end\n  end\nend\n\nafter 'deploy:updated', 'deploy:parallel_assets'\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Here, ",(0,t.jsx)(a.code,{children:"limit: 3"})," runs the task on up to three servers concurrently, and ",(0,t.jsx)(a.code,{children:"wait: 5"})," seconds between batches. Adjust those values based on your fleet size. This approach dramatically reduces the wall-clock time for asset compilation on multi-server setups."]})]})}function d(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},65404:(e,a,s)=>{s.d(a,{R:()=>l,x:()=>o});var n=s(36672);const t={},r=n.createContext(t);function l(e){const a=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(r.Provider,{value:a},e.children)}}}]);