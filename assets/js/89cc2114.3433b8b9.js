"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[66800],{65404:(e,t,a)=>{a.d(t,{R:()=>c,x:()=>o});var n=a(36672);const r={},s=n.createContext(r);function c(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(s.Provider,{value:t},e.children)}},96640:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"gems/factory_bot_rails/expert/after_create_callbacks_external_service_setup","title":"after_create_callbacks_external_service_setup","description":"\ud83c\udf10 Use Callbacks to Stub External Services and Seed Complex State","source":"@site/docs/gems/factory_bot_rails/expert/after_create_callbacks_external_service_setup.md","sourceDirName":"gems/factory_bot_rails/expert","slug":"/gems/factory_bot_rails/expert/after_create_callbacks_external_service_setup","permalink":"/keep-being-human-dev/docs/gems/factory_bot_rails/expert/after_create_callbacks_external_service_setup","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/factory_bot_rails/expert/after_create_callbacks_external_service_setup.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"using_traits.md","permalink":"/keep-being-human-dev/docs/gems/factory_bot_rails/beginner/using_traits.md"},"next":{"title":"custom_to_create_bulk_insert_strategy","permalink":"/keep-being-human-dev/docs/gems/factory_bot_rails/expert/custom_to_create_bulk_insert_strategy"}}');var r=a(23420),s=a(65404);const c={},o=void 0,i={},l=[{value:"\ud83c\udf10 Use Callbacks to Stub External Services and Seed Complex State",id:"-use-callbacks-to-stub-external-services-and-seed-complex-state",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"-use-callbacks-to-stub-external-services-and-seed-complex-state",children:"\ud83c\udf10 Use Callbacks to Stub External Services and Seed Complex State"}),"\n",(0,r.jsx)(t.p,{children:"For scenarios where creating a record triggers external API calls or background jobs, tie into FactoryBot\u2019s callbacks to stub these interactions or enqueue test\u2011friendly jobs. This ensures your factories remain reliable and side\u2011effect free in test environments."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:'FactoryBot.define do\n  factory :payment do\n    amount { 1000 }\n    status { :pending }\n\n    after(:build) do |payment|\n      # Prevent real Stripe client from initializing\n      allow(Stripe::Charge).to receive(:create).and_return(\n        OpenStruct.new(id: "ch_test_123", status: "succeeded")\n      )\n    end\n\n    after(:create) do |payment|\n      # Seed application state or async jobs\n      payment.update!(status: :succeeded)\n      payment.transactions.create!(external_id: "txn_#{SecureRandom.hex(4)}")\n      # Enqueue a lightweight test job instead of real one\n      TestWorker.perform_async(payment.id)\n    end\n  end\nend\n\n# In your spec:\npayment = create(:payment)\nexpect(payment.status).to eq("succeeded")\nexpect(TestWorker).to have_enqueued_sidekiq_job(payment.id)\n'})}),"\n",(0,r.jsx)(t.p,{children:"This pattern isolates external dependencies and seeds downstream objects or jobs reliably at factory time."})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);