"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[30832],{65404:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>o});var r=n(36672);const s={},a=r.createContext(s);function d(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(a.Provider,{value:t},e.children)}},70189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>l,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ruby/set/expert/thread_safe_set.md","title":"thread_safe_set.md","description":"\ud83d\udd12 Building a Thread\u2011Safe Set","source":"@site/docs/ruby/set/expert/thread_safe_set.md.md","sourceDirName":"ruby/set/expert","slug":"/ruby/set/expert/thread_safe_set.md","permalink":"/keep-being-human-dev/docs/ruby/set/expert/thread_safe_set.md","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/set/expert/thread_safe_set.md.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"lazy_unique_filter.md","permalink":"/keep-being-human-dev/docs/ruby/set/expert/lazy_unique_filter.md"},"next":{"title":"custom_object_set","permalink":"/keep-being-human-dev/docs/ruby/set/middle/custom_object_set"}}');var s=n(23420),a=n(65404);const d={},o=void 0,i={},c=[{value:"\ud83d\udd12 Building a Thread\u2011Safe Set",id:"-building-a-threadsafe-set",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"-building-a-threadsafe-set",children:"\ud83d\udd12 Building a Thread\u2011Safe Set"}),"\n",(0,s.jsxs)(t.p,{children:["Ruby\u2019s ",(0,s.jsx)(t.code,{children:"Set"})," isn\u2019t thread\u2011safe by default. For high\u2011concurrency environments, wrap operations in a mutex (or use ",(0,s.jsx)(t.code,{children:"Monitor"}),") so that readers and writers don\u2019t interleave and corrupt internal state."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:"require 'set'\nrequire 'monitor'\n\nclass ConcurrentSet < Set\n  def initialize(enum = nil)\n    super\n    @monitor = Monitor.new\n  end\n\n  [:add?, :delete, :include?, :merge, :subtract].each do |method_name|\n    define_method(method_name) do |*args, &block|\n      @monitor.synchronize { super(*args, &block) }\n    end\n  end\nend\n\ncs = ConcurrentSet.new\nthreads = 10.times.map do\n  Thread.new do\n    1000.times { |i| cs.add?(i) }\n  end\nend\nthreads.each(&:join)\nputs cs.size  # => 1000 without race conditions\n"})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);