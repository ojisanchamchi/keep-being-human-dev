"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[95586],{65404:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(36672);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}},76899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"gems/httparty/advanced/httparty_with_retry","title":"httparty_with_retry","description":"\ud83d\udd04 Implementing Retries with Exponential Backoff","source":"@site/docs/gems/httparty/advanced/httparty_with_retry.md","sourceDirName":"gems/httparty/advanced","slug":"/gems/httparty/advanced/httparty_with_retry","permalink":"/keep-being-human-dev/docs/gems/httparty/advanced/httparty_with_retry","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/httparty/advanced/httparty_with_retry.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_httparty_parser","permalink":"/keep-being-human-dev/docs/gems/httparty/advanced/custom_httparty_parser"},"next":{"title":"basic_get_request","permalink":"/keep-being-human-dev/docs/gems/httparty/beginner/basic_get_request"}}');var a=n(23420),s=n(65404);const i={},o=void 0,c={},d=[{value:"\ud83d\udd04 Implementing Retries with Exponential Backoff",id:"-implementing-retries-with-exponential-backoff",level:2}];function p(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"-implementing-retries-with-exponential-backoff",children:"\ud83d\udd04 Implementing Retries with Exponential Backoff"}),"\n",(0,a.jsxs)(t.p,{children:["HTTParty doesn\u2019t provide built\u2011in retry logic, but you can wrap requests to handle transient failures. Here\u2019s how to add exponential backoff and retry on 5xx or network errors by extending ",(0,a.jsx)(t.code,{children:"HTTParty::Request"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ruby",children:"require 'httparty'\n\nmodule HTTParty\n  class Request\n    alias_method :orig_perform, :perform\n\n    def perform(&block)\n      retries = 0\n      begin\n        orig_perform(&block)\n      rescue Errno::ETIMEDOUT, Errno::ECONNREFUSED, Net::OpenTimeout, Net::ReadTimeout, SocketError, HTTParty::Error => e\n        if retries < 3\n          backoff = (2 ** retries) + rand\n          sleep(backoff)\n          retries += 1\n          retry\n        end\n        raise e\n      end\n    end\n  end\nend\n\nclass ResilientClient\n  include HTTParty\n  base_uri 'https://unstable-api.example.com'\n\n  def fetch_resources\n    self.class.get('/resources')\n  end\nend\n\nclient = ResilientClient.new\nputs client.fetch_resources.code # will retry up to 3 times on failure\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);