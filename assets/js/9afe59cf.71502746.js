"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[2803],{59246:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>s,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"rails/active_support/advanced/advanced_cache_fetch_multi","title":"advanced_cache_fetch_multi","description":"\u26a1 Batch Fetch with fetch_multi and Namespaced Caching","source":"@site/docs/rails/active_support/advanced/advanced_cache_fetch_multi.md","sourceDirName":"rails/active_support/advanced","slug":"/rails/active_support/advanced/advanced_cache_fetch_multi","permalink":"/keep-being-human-dev/docs/rails/active_support/advanced/advanced_cache_fetch_multi","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_support/advanced/advanced_cache_fetch_multi.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"validating_active_storage_attachments","permalink":"/keep-being-human-dev/docs/rails/active_storage/middle/validating_active_storage_attachments"},"next":{"title":"concern_modularization","permalink":"/keep-being-human-dev/docs/rails/active_support/advanced/concern_modularization"}}');var n=a(23420),i=a(65404);const s={},r=void 0,d={},o=[{value:"\u26a1 Batch Fetch with fetch_multi and Namespaced Caching",id:"-batch-fetch-with-fetch_multi-and-namespaced-caching",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"-batch-fetch-with-fetch_multi-and-namespaced-caching",children:"\u26a1 Batch Fetch with fetch_multi and Namespaced Caching"}),"\n",(0,n.jsxs)(t.p,{children:["Rails.cache provides ",(0,n.jsx)(t.code,{children:"fetch_multi"})," for reducing N+1 cache reads by fetching multiple keys in a single call. Combine this with namespacing and versioning to safely expire segments of your cache without clearing everything. Great for preloading associations or bulk lookups."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"keys = %i[user_1 user_2 user_3]\nusers = Rails.cache.fetch_multi(*keys, namespace: 'v2', expires_in: 6.hours) do |key|\n  id = key.to_s.split('_').last.to_i\n  User.includes(:profile).find(id)\nend\n# users is a hash: { user_1: <User id=1>, ... }\n"})})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},65404:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>r});var c=a(36672);const n={},i=c.createContext(n);function s(e){const t=c.useContext(i);return c.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),c.createElement(i.Provider,{value:t},e.children)}}}]);