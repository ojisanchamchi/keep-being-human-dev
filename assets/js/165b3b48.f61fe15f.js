"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[45144],{59951:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ruby/yaml/expert/streaming_yaml_parser","title":"streaming_yaml_parser","description":"\ud83d\udcca Event-Driven Streaming Parsing for Large YAML Files","source":"@site/docs/ruby/yaml/expert/streaming_yaml_parser.md","sourceDirName":"ruby/yaml/expert","slug":"/ruby/yaml/expert/streaming_yaml_parser","permalink":"/keep-being-human-dev/docs/ruby/yaml/expert/streaming_yaml_parser","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/yaml/expert/streaming_yaml_parser.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"secure_yaml_safe_load","permalink":"/keep-being-human-dev/docs/ruby/yaml/expert/secure_yaml_safe_load"},"next":{"title":"custom_yaml_serialization","permalink":"/keep-being-human-dev/docs/ruby/yaml/middle/custom_yaml_serialization"}}');var t=a(23420),s=a(65404);const i={},l=void 0,o={},c=[{value:"\ud83d\udcca Event-Driven Streaming Parsing for Large YAML Files",id:"-event-driven-streaming-parsing-for-large-yaml-files",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"-event-driven-streaming-parsing-for-large-yaml-files",children:"\ud83d\udcca Event-Driven Streaming Parsing for Large YAML Files"}),"\n",(0,t.jsxs)(n.p,{children:["When dealing with multi-gigabyte YAML documents, loading the entire file into memory is impractical. Use ",(0,t.jsx)(n.code,{children:"Psych::Parser"})," with a custom event handler to process tokens (scalars, mappings, sequences) on\u2011the\u2011fly, achieving constant memory usage. This pattern is ideal for ETL pipelines, log processing, or any service that must handle YAML streams in real time."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"require 'psych'\n\nclass EventHandler < Psych::Handler\n  def initialize\n    @path = []\n  end\n\n  def start_mapping(anchor, tag, implicit, style)\n    @path.push({})\n  end\n\n  def scalar(value, anchor, tag, plain, quoted, style)\n    # Handle each scalar event as it arrives\n    puts \"Encountered: #{value} at depth #{@path.size}\"\n  end\n\n  def end_mapping\n    @path.pop\n  end\nend\n\nhandler = EventHandler.new\nparser = Psych::Parser.new(handler)\nFile.open('large_data.yaml', 'r') do |f|\n  f.each_line { |line| parser.parse(line) }\nend\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var r=a(36672);const t={},s=r.createContext(t);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);