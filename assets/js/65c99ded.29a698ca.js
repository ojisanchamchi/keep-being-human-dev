"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[49568],{43709:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"ruby/set/expert/custom_hash_eql.md","title":"custom_hash_eql.md","description":"\u267e\ufe0f Custom Equality and Hashing for Complex Objects","source":"@site/docs/ruby/set/expert/custom_hash_eql.md.md","sourceDirName":"ruby/set/expert","slug":"/ruby/set/expert/custom_hash_eql.md","permalink":"/keep-being-human-dev/docs/ruby/set/expert/custom_hash_eql.md","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/set/expert/custom_hash_eql.md.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"manage_set_elements","permalink":"/keep-being-human-dev/docs/ruby/set/beginner/manage_set_elements"},"next":{"title":"lazy_unique_filter.md","permalink":"/keep-being-human-dev/docs/ruby/set/expert/lazy_unique_filter.md"}}');var a=n(23420),o=n(65404);const r={},i=void 0,d={},m=[{value:"\u267e\ufe0f Custom Equality and Hashing for Complex Objects",id:"\ufe0f-custom-equality-and-hashing-for-complex-objects",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"\ufe0f-custom-equality-and-hashing-for-complex-objects",children:"\u267e\ufe0f Custom Equality and Hashing for Complex Objects"}),"\n",(0,a.jsxs)(t.p,{children:["When you store custom objects in a Set, Ruby uses ",(0,a.jsx)(t.code,{children:"hash"})," and ",(0,a.jsx)(t.code,{children:"eql?"})," to decide uniqueness. By overriding these methods you can group objects by any combination of attributes, even nested structures. This lets you dedupe complex data without extra iteration."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ruby",children:"require 'set'\n\nclass Event\n  attr_reader :name, :timestamp, :metadata\n  def initialize(name, timestamp, metadata = {})\n    @name, @timestamp, @metadata = name, timestamp, metadata\n  end\n\n  # Only name and date portion of timestamp matter for uniqueness\n  def hash\n    [name, timestamp.to_date].hash\n  end\n\n  def eql?(other)\n    other.is_a?(Event) && name == other.name && timestamp.to_date == other.timestamp.to_date\n  end\nend\n\nevents = Set.new\n# Two events at different times on same day are treated as duplicates\nevents << Event.new('deploy', Time.now)\nevents << Event.new('deploy', Time.now - 3600)\n\nputs events.size  # => 1\n"})})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var s=n(36672);const a={},o=s.createContext(a);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);