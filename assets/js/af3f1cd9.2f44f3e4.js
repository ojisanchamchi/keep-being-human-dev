"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[84504],{8374:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"ruby/benchmarking/expert/custom_harness_with_warmup","title":"custom_harness_with_warmup","description":"\u2699\ufe0f Build a Custom Benchmarking Harness with Warmup and Teardown","source":"@site/docs/ruby/benchmarking/expert/custom_harness_with_warmup.md","sourceDirName":"ruby/benchmarking/expert","slug":"/ruby/benchmarking/expert/custom_harness_with_warmup","permalink":"/keep-being-human-dev/docs/ruby/benchmarking/expert/custom_harness_with_warmup","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/benchmarking/expert/custom_harness_with_warmup.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"c_extension_performance_comparison","permalink":"/keep-being-human-dev/docs/ruby/benchmarking/expert/c_extension_performance_comparison"},"next":{"title":"memory_and_gc_profiling","permalink":"/keep-being-human-dev/docs/ruby/benchmarking/expert/memory_and_gc_profiling"}}');var t=r(23420),a=r(65404);const c={},i=void 0,o={},u=[{value:"\u2699\ufe0f Build a Custom Benchmarking Harness with Warmup and Teardown",id:"\ufe0f-build-a-custom-benchmarking-harness-with-warmup-and-teardown",level:2}];function m(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"\ufe0f-build-a-custom-benchmarking-harness-with-warmup-and-teardown",children:"\u2699\ufe0f Build a Custom Benchmarking Harness with Warmup and Teardown"}),"\n",(0,t.jsx)(n.p,{children:"For enterprise-grade services, you need benchmarks that reflect real-world workloads. Implement a harness that runs multiple warmup cycles, triggers full GC, and collects metrics at each stage to isolate JIT/bytecode cache effects."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class BenchmarkHarness\n  def initialize(iterations:, warmup_cycles:)\n    @iterations = iterations\n    @warmup_cycles = warmup_cycles\n    @results = []\n  end\n\n  def run\n    @warmup_cycles.times { GC.start }\n    @warmup_cycles.times { yield }  # warmup\n\n    @iterations.times do |i|\n      GC.start(full_mark: true, immediate_sweep: true)\n      t0 = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      yield\n      t1 = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      @results << (t1 - t0)\n    end\n    summarize\n  end\n\n  def summarize\n    avg = @results.sum / @results.size\n    sd = Math.sqrt(@results.map { |x| (x - avg)**2 }.sum / @results.size)\n    { average: avg, std_dev: sd, samples: @results.size }\n  end\nend\n\n# Usage\nharness = BenchmarkHarness.new(iterations: 50, warmup_cycles: 10)\nstats = harness.run { MyService.call(payload) }\nputs stats\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},65404:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>i});var s=r(36672);const t={},a=s.createContext(t);function c(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);