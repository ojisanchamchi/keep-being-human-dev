"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[47749],{9778:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"ruby/fibers/advanced/fiber_async_io","title":"fiber_async_io","description":"\ud83d\ude80 Concurrent IO Without Threads Using Fibers","source":"@site/docs/ruby/fibers/advanced/fiber_async_io.md","sourceDirName":"ruby/fibers/advanced","slug":"/ruby/fibers/advanced/fiber_async_io","permalink":"/keep-being-human-dev/docs/ruby/fibers/advanced/fiber_async_io","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/fibers/advanced/fiber_async_io.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"retry_transient_errors","permalink":"/keep-being-human-dev/docs/ruby/exceptions/middle/retry_transient_errors"},"next":{"title":"fiber_data_pipeline","permalink":"/keep-being-human-dev/docs/ruby/fibers/advanced/fiber_data_pipeline"}}');var i=r(23420),s=r(65404);const o={},a=void 0,c={},d=[{value:"\ud83d\ude80 Concurrent IO Without Threads Using Fibers",id:"-concurrent-io-without-threads-using-fibers",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"-concurrent-io-without-threads-using-fibers",children:"\ud83d\ude80 Concurrent IO Without Threads Using Fibers"}),"\n",(0,i.jsxs)(n.p,{children:["Leverage ",(0,i.jsx)(n.code,{children:"IO.select"})," inside fibers to multiplex socket or file IO, achieving non\u2011blocking behavior without spawning OS threads. By resuming fibers when their IO is readable or writable, you can manage thousands of connections in a single reactor loop."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'clients = []\nserver = TCPServer.new(1234)\n\ndef handle(client)\n  loop do\n    data = client.read_nonblock(1024)\n    break if data.empty?\n    client.write "Echo: #{data}"\n  end\nrescue IO::WaitReadable, IO::WaitWritable\n  Fiber.yield client\nensure\n  client.close\nend\n\nreactor = Fiber.new do\n  loop do\n    r, w = IO.select(clients + [server], clients)\n    if r.include? server\n      sock = server.accept_nonblock\n      clients << sock\n      f = Fiber.new { handle(sock) }\n      clients << f.resume\n    end\n    (r + w).each { |sock| Fiber.schedule(sock) }\n  end\nend\n\nreactor.resume\n'})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},65404:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(36672);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);