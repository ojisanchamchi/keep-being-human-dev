"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[82067],{45665:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"nosql/redis/advanced/redis_lua_scripting","title":"redis_lua_scripting","description":"\ud83c\udfaf Use Lua Scripting for Atomic Operations","source":"@site/docs/nosql/redis/advanced/redis_lua_scripting.md","sourceDirName":"nosql/redis/advanced","slug":"/nosql/redis/advanced/redis_lua_scripting","permalink":"/keep-being-human-dev/docs/nosql/redis/advanced/redis_lua_scripting","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nosql/redis/advanced/redis_lua_scripting.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"turbo_stimulus_integration","permalink":"/keep-being-human-dev/docs/javascript/turbo/middle/turbo_stimulus_integration"},"next":{"title":"redis_pipelining","permalink":"/keep-being-human-dev/docs/nosql/redis/advanced/redis_pipelining"}}');var s=i(23420),r=i(65404);const a={},o=void 0,c={},d=[{value:"\ud83c\udfaf Use Lua Scripting for Atomic Operations",id:"-use-lua-scripting-for-atomic-operations",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"-use-lua-scripting-for-atomic-operations",children:"\ud83c\udfaf Use Lua Scripting for Atomic Operations"}),"\n",(0,s.jsxs)(n.p,{children:["Lua scripts in Redis ensure that a sequence of operations is executed atomically, avoiding race conditions without external locks. You can bundle complex logic (e.g., conditional updates, increments, and expirations) into one script and call it via ",(0,s.jsx)(n.code,{children:"EVAL"}),", reducing latency and improving consistency. Always load scripts with ",(0,s.jsx)(n.code,{children:"SCRIPT LOAD"})," to get a SHA for faster execution with ",(0,s.jsx)(n.code,{children:"EVALSHA"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"require 'redis'\nredis = Redis.new\n\n# Define a Lua script that increments a counter and sets an expiry only on first use\nlua = <<~LUA\n  local current = redis.call('INCR', KEYS[1])\n  if current == 1 then\n    redis.call('EXPIRE', KEYS[1], ARGV[1])\n  end\n  return current\nLUA\n\n# Load script and store its SHA1 hash\nsha = redis.script(:load, lua)\n\n# Execute the script atomically using EVALSHA\ncount = redis.evalsha(sha, keys: ['page:42:views'], argv: ['3600'])\nputs \"Page 42 view count: #{count}\"\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},65404:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(36672);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);