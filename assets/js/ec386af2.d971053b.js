"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[29865],{35442:n=>{n.exports=JSON.parse('{"permalink":"/keep-being-human-dev/blog/ruby-concurrency-mutexes-tu-co-ban-den-nang-cao","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/ruby-concurrency-mutexes-tu-co-ban-den-nang-cao.md","source":"@site/blog/ruby-concurrency-mutexes-tu-co-ban-den-nang-cao.md","title":"Ruby Concurrency & Mutexes: T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao - H\u01b0\u1edbng D\u1eabn To\xe0n Di\u1ec7n","description":"Concurrency (\u0111\u1ed3ng th\u1eddi) l\xe0 m\u1ed9t trong nh\u1eefng ch\u1ee7 \u0111\u1ec1 ph\u1ee9c t\u1ea1p nh\u1ea5t trong l\u1eadp tr\xecnh, nh\u01b0ng c\u0169ng l\xe0 ch\xeca kh\xf3a \u0111\u1ec3 t\u1ea1o ra nh\u1eefng \u1ee9ng d\u1ee5ng Ruby hi\u1ec7u su\u1ea5t cao. Trong b\xe0i vi\u1ebft n\xe0y, ch\xfang ta s\u1ebd kh\xe1m ph\xe1 t\u1eeb nh\u1eefng kh\xe1i ni\u1ec7m c\u01a1 b\u1ea3n v\u1ec1 threads v\xe0 mutexes \u0111\u1ebfn c\xe1c k\u1ef9 thu\u1eadt n\xe2ng cao nh\u01b0 lock striping v\xe0 fair mutexes.","date":"2025-07-24T10:20:47.000Z","tags":[{"inline":false,"label":"Ruby","permalink":"/keep-being-human-dev/blog/tags/ruby","description":"Content related to Ruby programming language"},{"inline":false,"label":"Concurrency","permalink":"/keep-being-human-dev/blog/tags/concurrency","description":"Content about concurrent programming and parallel execution"},{"inline":false,"label":"Mutex","permalink":"/keep-being-human-dev/blog/tags/mutex","description":"Content about mutual exclusion and thread synchronization"},{"inline":false,"label":"Threading","permalink":"/keep-being-human-dev/blog/tags/threading","description":"Content about multi-threading and thread management"},{"inline":false,"label":"Synchronization","permalink":"/keep-being-human-dev/blog/tags/synchronization","description":"Content about thread synchronization techniques and patterns"},{"inline":false,"label":"Performance","permalink":"/keep-being-human-dev/blog/tags/performance","description":"Content related to performance optimization and techniques"},{"inline":false,"label":"Parallel Programming","permalink":"/keep-being-human-dev/blog/tags/parallel","description":"Content about parallel programming and concurrent execution"}],"readingTime":14.19,"hasTruncateMarker":true,"authors":[{"name":"Dang Quang Minh","title":"Nh\xe2n vi\xean o\xe1nh m\xe1y t\xednh","url":"https://github.com/ojisanchamchi","page":{"permalink":"/keep-being-human-dev/blog/authors/admin"},"socials":{"github":"https://github.com/ojisanchamchi"},"imageURL":"https://github.com/ojisanchamchi.png","key":"admin"}],"frontMatter":{"slug":"ruby-concurrency-mutexes-tu-co-ban-den-nang-cao","title":"Ruby Concurrency & Mutexes: T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao - H\u01b0\u1edbng D\u1eabn To\xe0n Di\u1ec7n","authors":["admin"],"tags":["ruby","concurrency","mutex","threading","synchronization","performance","parallel"]},"unlisted":false,"prevItem":{"title":"Ruby Compression: T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao - H\u01b0\u1edbng D\u1eabn To\xe0n Di\u1ec7n","permalink":"/keep-being-human-dev/blog/ruby-compression-tu-co-ban-den-nang-cao"},"nextItem":{"title":"Ruby Classes v\xe0 Modules - T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao Cho Developer","permalink":"/keep-being-human-dev/blog/ruby-classes-modules-tu-co-ban-den-nang-cao"}}')},39036:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>d,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=t(35442),r=t(23420),o=t(65404);const a={slug:"ruby-concurrency-mutexes-tu-co-ban-den-nang-cao",title:"Ruby Concurrency & Mutexes: T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao - H\u01b0\u1edbng D\u1eabn To\xe0n Di\u1ec7n",authors:["admin"],tags:["ruby","concurrency","mutex","threading","synchronization","performance","parallel"]},d="Ruby Concurrency & Mutexes: T\u1eeb C\u01a1 B\u1ea3n \u0110\u1ebfn N\xe2ng Cao",s={authorsImageUrls:[void 0]},c=[{value:"T\u1ea1i Sao C\u1ea7n Concurrency?",id:"t\u1ea1i-sao-c\u1ea7n-concurrency",level:2},{value:"V\u1ea5n \u0110\u1ec1 Race Conditions",id:"v\u1ea5n-\u0111\u1ec1-race-conditions",level:2},{value:"Ph\u1ea7n 1: C\u01a1 B\u1ea3n - L\xe0m Quen V\u1edbi Mutex",id:"ph\u1ea7n-1-c\u01a1-b\u1ea3n---l\xe0m-quen-v\u1edbi-mutex",level:2},{value:"1.1 B\u1ea3o V\u1ec7 Shared Counter V\u1edbi Mutex",id:"11-b\u1ea3o-v\u1ec7-shared-counter-v\u1edbi-mutex",level:3},{value:"1.2 Manual Lock v\xe0 Unlock",id:"12-manual-lock-v\xe0-unlock",level:3},{value:"1.3 Mutex Per Resource Pattern",id:"13-mutex-per-resource-pattern",level:3},{value:"1.4 Ch\u1edd Threads Ho\xe0n Th\xe0nh V\u1edbi Join",id:"14-ch\u1edd-threads-ho\xe0n-th\xe0nh-v\u1edbi-join",level:3},{value:"Ph\u1ea7n 2: Trung C\u1ea5p - K\u1ef9 Thu\u1eadt N\xe2ng Cao",id:"ph\u1ea7n-2-trung-c\u1ea5p---k\u1ef9-thu\u1eadt-n\xe2ng-cao",level:2},{value:"2.1 Thread-Safe Class Design",id:"21-thread-safe-class-design",level:3},{value:"2.2 Non-Blocking Lock V\u1edbi try_lock",id:"22-non-blocking-lock-v\u1edbi-try_lock",level:3},{value:"2.3 ConditionVariable - Coordination Between Threads",id:"23-conditionvariable---coordination-between-threads",level:3},{value:"2.4 Double-Checked Locking Pattern",id:"24-double-checked-locking-pattern",level:3},{value:"Ph\u1ea7n 3: N\xe2ng Cao - K\u1ef9 Thu\u1eadt Chuy\xean Nghi\u1ec7p",id:"ph\u1ea7n-3-n\xe2ng-cao---k\u1ef9-thu\u1eadt-chuy\xean-nghi\u1ec7p",level:2},{value:"3.1 Monitor - Reentrant Mutex",id:"31-monitor---reentrant-mutex",level:3},{value:"3.2 Deadlock Prevention",id:"32-deadlock-prevention",level:3},{value:"Ph\u1ea7n 4: Expert Level - K\u1ef9 Thu\u1eadt Chuy\xean Gia",id:"ph\u1ea7n-4-expert-level---k\u1ef9-thu\u1eadt-chuy\xean-gia",level:2},{value:"4.1 Lock Striping - Sharded Mutex Pool",id:"41-lock-striping---sharded-mutex-pool",level:3},{value:"4.2 Fair FIFO Mutex",id:"42-fair-fifo-mutex",level:3},{value:"4.3 Custom Reentrant Mutex",id:"43-custom-reentrant-mutex",level:3},{value:"4.4 Thread Pool With Work Stealing",id:"44-thread-pool-with-work-stealing",level:3},{value:"Best Practices v\xe0 L\u01b0u \xdd",id:"best-practices-v\xe0-l\u01b0u-\xfd",level:2},{value:"1. Tr\xe1nh Common Pitfalls",id:"1-tr\xe1nh-common-pitfalls",level:3},{value:"2. Performance Tips",id:"2-performance-tips",level:3},{value:"3. Debugging Concurrent Code",id:"3-debugging-concurrent-code",level:3},{value:"K\u1ebft Lu\u1eadn",id:"k\u1ebft-lu\u1eadn",level:2},{value:"Nh\u1eefng \u0111i\u1ec3m ch\xednh c\u1ea7n nh\u1edb:",id:"nh\u1eefng-\u0111i\u1ec3m-ch\xednh-c\u1ea7n-nh\u1edb",level:3},{value:"Khi n\xe0o s\u1eed d\u1ee5ng g\xec:",id:"khi-n\xe0o-s\u1eed-d\u1ee5ng-g\xec",level:3},{value:"L\u1eddi khuy\xean cu\u1ed1i:",id:"l\u1eddi-khuy\xean-cu\u1ed1i",level:3}];function u(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"Concurrency (\u0111\u1ed3ng th\u1eddi) l\xe0 m\u1ed9t trong nh\u1eefng ch\u1ee7 \u0111\u1ec1 ph\u1ee9c t\u1ea1p nh\u1ea5t trong l\u1eadp tr\xecnh, nh\u01b0ng c\u0169ng l\xe0 ch\xeca kh\xf3a \u0111\u1ec3 t\u1ea1o ra nh\u1eefng \u1ee9ng d\u1ee5ng Ruby hi\u1ec7u su\u1ea5t cao. Trong b\xe0i vi\u1ebft n\xe0y, ch\xfang ta s\u1ebd kh\xe1m ph\xe1 t\u1eeb nh\u1eefng kh\xe1i ni\u1ec7m c\u01a1 b\u1ea3n v\u1ec1 threads v\xe0 mutexes \u0111\u1ebfn c\xe1c k\u1ef9 thu\u1eadt n\xe2ng cao nh\u01b0 lock striping v\xe0 fair mutexes."}),"\n",(0,r.jsx)(e.h2,{id:"t\u1ea1i-sao-c\u1ea7n-concurrency",children:"T\u1ea1i Sao C\u1ea7n Concurrency?"}),"\n",(0,r.jsx)(e.p,{children:"Tr\u01b0\u1edbc khi \u0111i v\xe0o chi ti\u1ebft, h\xe3y hi\u1ec3u t\u1ea1i sao concurrency l\u1ea1i quan tr\u1ecdng:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"T\u0103ng hi\u1ec7u su\u1ea5t"}),": T\u1eadn d\u1ee5ng multi-core processors"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"C\u1ea3i thi\u1ec7n responsiveness"}),": UI kh\xf4ng b\u1ecb \u0111\xf3ng b\u0103ng khi x\u1eed l\xfd t\xe1c v\u1ee5 n\u1eb7ng"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"X\u1eed l\xfd I/O hi\u1ec7u qu\u1ea3"}),": Kh\xf4ng ch\u1edd \u0111\u1ee3i network/disk operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Scalability"}),": X\u1eed l\xfd nhi\u1ec1u requests \u0111\u1ed3ng th\u1eddi"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Resource utilization"}),": T\u1ed1i \u01b0u h\xf3a vi\u1ec7c s\u1eed d\u1ee5ng CPU v\xe0 memory"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"v\u1ea5n-\u0111\u1ec1-race-conditions",children:"V\u1ea5n \u0110\u1ec1 Race Conditions"}),"\n",(0,r.jsx)(e.p,{children:"Khi nhi\u1ec1u threads c\xf9ng truy c\u1eadp v\xe0 thay \u0111\u1ed5i d\u1eef li\u1ec7u chung, c\xf3 th\u1ec3 x\u1ea3y ra race conditions:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"# \u274c Kh\xf4ng an to\xe0n - Race condition\ncounter = 0\n\nthreads = 5.times.map do\n  Thread.new do\n    1000.times do\n      counter += 1  # Kh\xf4ng thread-safe!\n    end\n  end\nend\n\nthreads.each(&:join)\nputs counter  # K\u1ebft qu\u1ea3 kh\xf4ng \u0111o\xe1n tr\u01b0\u1edbc \u0111\u01b0\u1ee3c, th\u01b0\u1eddng < 5000\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"V\u1ea5n \u0111\u1ec1"}),": Ph\xe9p to\xe1n ",(0,r.jsx)(e.code,{children:"counter += 1"})," kh\xf4ng ph\u1ea3i l\xe0 atomic. N\xf3 bao g\u1ed3m 3 b\u01b0\u1edbc:"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"\u0110\u1ecdc gi\xe1 tr\u1ecb hi\u1ec7n t\u1ea1i"}),"\n",(0,r.jsx)(e.li,{children:"T\u0103ng gi\xe1 tr\u1ecb l\xean 1"}),"\n",(0,r.jsx)(e.li,{children:"Ghi l\u1ea1i gi\xe1 tr\u1ecb m\u1edbi"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Khi nhi\u1ec1u threads th\u1ef1c hi\u1ec7n \u0111\u1ed3ng th\u1eddi, c\xf3 th\u1ec3 d\u1eabn \u0111\u1ebfn m\u1ea5t d\u1eef li\u1ec7u."}),"\n",(0,r.jsx)(e.h2,{id:"ph\u1ea7n-1-c\u01a1-b\u1ea3n---l\xe0m-quen-v\u1edbi-mutex",children:"Ph\u1ea7n 1: C\u01a1 B\u1ea3n - L\xe0m Quen V\u1edbi Mutex"}),"\n",(0,r.jsx)(e.h3,{id:"11-b\u1ea3o-v\u1ec7-shared-counter-v\u1edbi-mutex",children:"1.1 B\u1ea3o V\u1ec7 Shared Counter V\u1edbi Mutex"}),"\n",(0,r.jsx)(e.p,{children:"Mutex (Mutual Exclusion) \u0111\u1ea3m b\u1ea3o ch\u1ec9 c\xf3 m\u1ed9t thread \u0111\u01b0\u1ee3c truy c\u1eadp critical section t\u1ea1i m\u1ed9t th\u1eddi \u0111i\u1ec3m:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"require 'thread'\n\ndef safe_counter_example\n  mutex = Mutex.new\n  counter = 0\n\n  threads = 5.times.map do\n    Thread.new do\n      1000.times do\n        mutex.synchronize do\n          counter += 1  # Critical section \u0111\u01b0\u1ee3c b\u1ea3o v\u1ec7\n        end\n      end\n    end\n  end\n\n  threads.each(&:join)\n  puts \"K\u1ebft qu\u1ea3 an to\xe0n: #{counter}\"  # => 5000\nend\n\nsafe_counter_example\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Gi\u1ea3i th\xedch:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"Mutex.new"}),": T\u1ea1o m\u1ed9t mutex m\u1edbi"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"mutex.synchronize"}),": Kh\xf3a mutex, th\u1ef1c thi block, sau \u0111\xf3 m\u1edf kh\xf3a"]}),"\n",(0,r.jsx)(e.li,{children:"Ch\u1ec9 m\u1ed9t thread c\xf3 th\u1ec3 v\xe0o critical section t\u1ea1i m\u1ed9t th\u1eddi \u0111i\u1ec3m"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"12-manual-lock-v\xe0-unlock",children:"1.2 Manual Lock v\xe0 Unlock"}),"\n",(0,r.jsx)(e.p,{children:"\u0110\xf4i khi b\u1ea1n c\u1ea7n ki\u1ec3m so\xe1t chi ti\u1ebft h\u01a1n vi\u1ec7c kh\xf3a/m\u1edf kh\xf3a:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass ManualLockExample\n  def initialize\n    @mutex = Mutex.new\n    @data = []\n  end\n\n  def safe_update(value)\n    @mutex.lock\n    begin\n      # Critical section\n      puts "Thread #{Thread.current.object_id} \u0111ang x\u1eed l\xfd #{value}"\n      @data << value\n      sleep(0.01)  # Simulate work\n    ensure\n      @mutex.unlock  # Lu\xf4n unlock trong ensure block\n    end\n  end\n\n  def get_data\n    @mutex.synchronize { @data.dup }\n  end\nend\n\n# S\u1eed d\u1ee5ng\nexample = ManualLockExample.new\nthreads = 5.times.map do |i|\n  Thread.new { example.safe_update("data_#{i}") }\nend\n\nthreads.each(&:join)\nputs "D\u1eef li\u1ec7u cu\u1ed1i c\xf9ng: #{example.get_data}"\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"L\u01b0u \xfd quan tr\u1ecdng:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Lu\xf4n s\u1eed d\u1ee5ng ",(0,r.jsx)(e.code,{children:"ensure"})," \u0111\u1ec3 \u0111\u1ea3m b\u1ea3o mutex \u0111\u01b0\u1ee3c unlock"]}),"\n",(0,r.jsx)(e.li,{children:"Tr\xe1nh deadlock b\u1eb1ng c\xe1ch kh\xf4ng gi\u1eef lock qu\xe1 l\xe2u"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"13-mutex-per-resource-pattern",children:"1.3 Mutex Per Resource Pattern"}),"\n",(0,r.jsx)(e.p,{children:"T\u1ea1o m\u1ed9t mutex cho m\u1ed7i resource \u0111\u1ec3 tr\xe1nh blocking kh\xf4ng c\u1ea7n thi\u1ebft:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass BankAccount\n  def initialize(balance)\n    @balance = balance\n    @mutex = Mutex.new  # M\u1ed7i account c\xf3 mutex ri\xeang\n  end\n\n  def deposit(amount)\n    @mutex.synchronize do\n      old_balance = @balance\n      sleep(0.01)  # Simulate processing time\n      @balance = old_balance + amount\n      puts "G\u1eedi #{amount}, s\u1ed1 d\u01b0 m\u1edbi: #{@balance}"\n    end\n  end\n\n  def withdraw(amount)\n    @mutex.synchronize do\n      if @balance >= amount\n        old_balance = @balance\n        sleep(0.01)\n        @balance = old_balance - amount\n        puts "R\xfat #{amount}, s\u1ed1 d\u01b0 m\u1edbi: #{@balance}"\n        true\n      else\n        puts "Kh\xf4ng \u0111\u1ee7 s\u1ed1 d\u01b0 \u0111\u1ec3 r\xfat #{amount}"\n        false\n      end\n    end\n  end\n\n  def balance\n    @mutex.synchronize { @balance }\n  end\nend\n\n# Demo\naccount1 = BankAccount.new(1000)\naccount2 = BankAccount.new(500)\n\n# C\xe1c threads c\xf3 th\u1ec3 l\xe0m vi\u1ec7c v\u1edbi different accounts song song\nthreads = []\nthreads << Thread.new { account1.deposit(100) }\nthreads << Thread.new { account2.deposit(200) }\nthreads << Thread.new { account1.withdraw(50) }\nthreads << Thread.new { account2.withdraw(300) }\n\nthreads.each(&:join)\n\nputs "Account 1 balance: #{account1.balance}"\nputs "Account 2 balance: #{account2.balance}"\n'})}),"\n",(0,r.jsx)(e.h3,{id:"14-ch\u1edd-threads-ho\xe0n-th\xe0nh-v\u1edbi-join",children:"1.4 Ch\u1edd Threads Ho\xe0n Th\xe0nh V\u1edbi Join"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Thread#join"})," \u0111\u1ea3m b\u1ea3o main thread ch\u1edd c\xe1c worker threads ho\xe0n th\xe0nh:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\ndef demonstrate_join\n  mutex = Mutex.new\n  results = []\n  \n  puts "B\u1eaft \u0111\u1ea7u x\u1eed l\xfd..."\n  start_time = Time.now\n\n  threads = 4.times.map do |i|\n    Thread.new do\n      # Simulate different processing times\n      processing_time = rand(0.5..2.0)\n      sleep(processing_time)\n      \n      result = "K\u1ebft qu\u1ea3 t\u1eeb thread #{i} (#{processing_time.round(2)}s)"\n      \n      mutex.synchronize do\n        results << result\n        puts "\u2713 #{result}"\n      end\n    end\n  end\n\n  # Ch\u1edd t\u1ea5t c\u1ea3 threads ho\xe0n th\xe0nh\n  threads.each(&:join)\n  \n  end_time = Time.now\n  puts "\\nHo\xe0n th\xe0nh sau #{(end_time - start_time).round(2)}s"\n  puts "T\u1ed5ng c\u1ed9ng #{results.length} k\u1ebft qu\u1ea3"\nend\n\ndemonstrate_join\n'})}),"\n",(0,r.jsx)(e.h2,{id:"ph\u1ea7n-2-trung-c\u1ea5p---k\u1ef9-thu\u1eadt-n\xe2ng-cao",children:"Ph\u1ea7n 2: Trung C\u1ea5p - K\u1ef9 Thu\u1eadt N\xe2ng Cao"}),"\n",(0,r.jsx)(e.h3,{id:"21-thread-safe-class-design",children:"2.1 Thread-Safe Class Design"}),"\n",(0,r.jsx)(e.p,{children:"Thi\u1ebft k\u1ebf class thread-safe t\u1eeb \u0111\u1ea7u:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"require 'thread'\n\nclass ThreadSafeCounter\n  def initialize(initial_value = 0)\n    @count = initial_value\n    @mutex = Mutex.new\n  end\n\n  def increment(amount = 1)\n    @mutex.synchronize do\n      old_value = @count\n      sleep(0.001)  # Simulate work that could cause race condition\n      @count = old_value + amount\n    end\n  end\n\n  def decrement(amount = 1)\n    @mutex.synchronize do\n      old_value = @count\n      sleep(0.001)\n      @count = old_value - amount\n    end\n  end\n\n  def value\n    @mutex.synchronize { @count }\n  end\n\n  def reset(new_value = 0)\n    @mutex.synchronize { @count = new_value }\n  end\n\n  # Atomic operations\n  def increment_and_get(amount = 1)\n    @mutex.synchronize do\n      @count += amount\n      @count\n    end\n  end\n\n  def compare_and_set(expected, new_value)\n    @mutex.synchronize do\n      if @count == expected\n        @count = new_value\n        true\n      else\n        false\n      end\n    end\n  end\nend\n\n# Demo\ncounter = ThreadSafeCounter.new(100)\n\n# Test concurrent operations\nthreads = []\nthreads += 10.times.map { Thread.new { 100.times { counter.increment } } }\nthreads += 5.times.map { Thread.new { 50.times { counter.decrement } } }\n\nthreads.each(&:join)\n\nputs \"Final value: #{counter.value}\"  # Should be 100 + 1000 - 250 = 850\n"})}),"\n",(0,r.jsx)(e.h3,{id:"22-non-blocking-lock-v\u1edbi-try_lock",children:"2.2 Non-Blocking Lock V\u1edbi try_lock"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Mutex#try_lock"})," cho ph\xe9p th\u1eed kh\xf3a m\xe0 kh\xf4ng block thread:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass NonBlockingProcessor\n  def initialize\n    @mutex = Mutex.new\n    @processing = false\n    @queue = []\n  end\n\n  def add_task(task)\n    @mutex.synchronize { @queue << task }\n  end\n\n  def try_process\n    if @mutex.try_lock\n      begin\n        return false if @processing || @queue.empty?\n        \n        @processing = true\n        task = @queue.shift\n        \n        puts "#{Thread.current.object_id}: B\u1eaft \u0111\u1ea7u x\u1eed l\xfd #{task}"\n        sleep(0.1)  # Simulate work\n        puts "#{Thread.current.object_id}: Ho\xe0n th\xe0nh #{task}"\n        \n        true\n      ensure\n        @processing = false\n        @mutex.unlock\n      end\n    else\n      puts "#{Thread.current.object_id}: Kh\xf4ng th\u1ec3 l\u1ea5y lock, th\u1eed l\u1ea1i sau"\n      false\n    end\n  end\n\n  def queue_size\n    @mutex.synchronize { @queue.size }\n  end\nend\n\n# Demo\nprocessor = NonBlockingProcessor.new\n\n# Add tasks\n10.times { |i| processor.add_task("Task_#{i}") }\n\n# Multiple threads try to process\nthreads = 5.times.map do\n  Thread.new do\n    10.times do\n      success = processor.try_process\n      sleep(0.05) unless success\n    end\n  end\nend\n\nthreads.each(&:join)\nputs "Remaining tasks: #{processor.queue_size}"\n'})}),"\n",(0,r.jsx)(e.h3,{id:"23-conditionvariable---coordination-between-threads",children:"2.3 ConditionVariable - Coordination Between Threads"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ConditionVariable"})," gi\xfap threads ch\u1edd \u0111\u1ee3i v\xe0 th\xf4ng b\xe1o cho nhau:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass ProducerConsumerQueue\n  def initialize(max_size = 5)\n    @queue = []\n    @max_size = max_size\n    @mutex = Mutex.new\n    @not_empty = ConditionVariable.new\n    @not_full = ConditionVariable.new\n  end\n\n  def produce(item)\n    @mutex.synchronize do\n      # Ch\u1edd cho \u0111\u1ebfn khi queue kh\xf4ng full\n      while @queue.size >= @max_size\n        puts "Producer ch\u1edd - Queue full (#{@queue.size}/#{@max_size})"\n        @not_full.wait(@mutex)\n      end\n      \n      @queue << item\n      puts "Produced: #{item} (Queue: #{@queue.size}/#{@max_size})"\n      \n      # Th\xf4ng b\xe1o cho consumers\n      @not_empty.signal\n    end\n  end\n\n  def consume\n    @mutex.synchronize do\n      # Ch\u1edd cho \u0111\u1ebfn khi queue kh\xf4ng empty\n      while @queue.empty?\n        puts "Consumer ch\u1edd - Queue empty"\n        @not_empty.wait(@mutex)\n      end\n      \n      item = @queue.shift\n      puts "Consumed: #{item} (Queue: #{@queue.size}/#{@max_size})"\n      \n      # Th\xf4ng b\xe1o cho producers\n      @not_full.signal\n      \n      item\n    end\n  end\n\n  def size\n    @mutex.synchronize { @queue.size }\n  end\nend\n\n# Demo\nqueue = ProducerConsumerQueue.new(3)\n\n# Producer thread\nproducer = Thread.new do\n  10.times do |i|\n    queue.produce("Item_#{i}")\n    sleep(0.1)\n  end\nend\n\n# Consumer threads\nconsumers = 2.times.map do |i|\n  Thread.new do\n    5.times do\n      item = queue.consume\n      sleep(0.2)  # Simulate processing\n    end\n  end\nend\n\nproducer.join\nconsumers.each(&:join)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"24-double-checked-locking-pattern",children:"2.4 Double-Checked Locking Pattern"}),"\n",(0,r.jsx)(e.p,{children:"T\u1ed1i \u01b0u h\xf3a lazy initialization:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"require 'thread'\n\nclass ConfigurationManager\n  @instance = nil\n  @mutex = Mutex.new\n\n  def self.instance\n    # First check (kh\xf4ng c\u1ea7n lock)\n    return @instance if @instance\n\n    @mutex.synchronize do\n      # Second check (v\u1edbi lock)\n      @instance ||= new\n    end\n  end\n\n  def initialize\n    puts \"Kh\u1edfi t\u1ea1o Configuration...\"\n    sleep(0.2)  # Simulate expensive initialization\n    @config = load_configuration\n  end\n\n  private\n\n  def load_configuration\n    {\n      database: {\n        host: 'localhost',\n        port: 5432,\n        pool_size: 10\n      },\n      cache: {\n        ttl: 3600,\n        max_size: 1000\n      },\n      api: {\n        timeout: 30,\n        retries: 3\n      }\n    }\n  end\n\n  def config\n    @config\n  end\nend\n\n# Test concurrent access\nthreads = 10.times.map do |i|\n  Thread.new do\n    config = ConfigurationManager.instance\n    puts \"Thread #{i}: #{config.object_id}\"\n  end\nend\n\nthreads.each(&:join)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"ph\u1ea7n-3-n\xe2ng-cao---k\u1ef9-thu\u1eadt-chuy\xean-nghi\u1ec7p",children:"Ph\u1ea7n 3: N\xe2ng Cao - K\u1ef9 Thu\u1eadt Chuy\xean Nghi\u1ec7p"}),"\n",(0,r.jsx)(e.h3,{id:"31-monitor---reentrant-mutex",children:"3.1 Monitor - Reentrant Mutex"}),"\n",(0,r.jsxs)(e.p,{children:["Ruby's ",(0,r.jsx)(e.code,{children:"Monitor"})," cho ph\xe9p c\xf9ng m\u1ed9t thread lock nhi\u1ec1u l\u1ea7n:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"require 'monitor'\n\nclass ThreadSafeBank\n  include MonitorMixin\n\n  def initialize\n    super()  # Initialize MonitorMixin\n    @accounts = {}\n  end\n\n  def create_account(id, initial_balance)\n    synchronize do\n      @accounts[id] = initial_balance\n      log_transaction(\"Created account #{id} with balance #{initial_balance}\")\n    end\n  end\n\n  def transfer(from_id, to_id, amount)\n    synchronize do\n      return false unless @accounts[from_id] && @accounts[to_id]\n      return false if @accounts[from_id] < amount\n\n      # Nested synchronization - Monitor cho ph\xe9p reentrant\n      withdraw_internal(from_id, amount)\n      deposit_internal(to_id, amount)\n      \n      log_transaction(\"Transferred #{amount} from #{from_id} to #{to_id}\")\n      true\n    end\n  end\n\n  def get_balance(id)\n    synchronize { @accounts[id] }\n  end\n\n  private\n\n  def withdraw_internal(id, amount)\n    synchronize do  # Reentrant lock\n      @accounts[id] -= amount\n    end\n  end\n\n  def deposit_internal(id, amount)\n    synchronize do  # Reentrant lock\n      @accounts[id] += amount\n    end\n  end\n\n  def log_transaction(message)\n    synchronize do  # Reentrant lock\n      puts \"[#{Time.now}] #{message}\"\n    end\n  end\nend\n\n# Demo\nbank = ThreadSafeBank.new\nbank.create_account('A', 1000)\nbank.create_account('B', 500)\n\nthreads = []\nthreads << Thread.new { bank.transfer('A', 'B', 100) }\nthreads << Thread.new { bank.transfer('B', 'A', 50) }\nthreads << Thread.new { puts \"Balance A: #{bank.get_balance('A')}\" }\nthreads << Thread.new { puts \"Balance B: #{bank.get_balance('B')}\" }\n\nthreads.each(&:join)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"32-deadlock-prevention",children:"3.2 Deadlock Prevention"}),"\n",(0,r.jsx)(e.p,{children:"Tr\xe1nh deadlock b\u1eb1ng ordered locking:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"require 'thread'\n\nclass DeadlockSafeTransfer\n  def initialize\n    @accounts = {}\n    @mutexes = {}\n  end\n\n  def create_account(id, balance)\n    @accounts[id] = balance\n    @mutexes[id] = Mutex.new\n  end\n\n  def transfer_safe(from_id, to_id, amount)\n    # Lu\xf4n lock theo th\u1ee9 t\u1ef1 object_id \u0111\u1ec3 tr\xe1nh deadlock\n    first_id, second_id = [from_id, to_id].sort\n    first_mutex = @mutexes[first_id]\n    second_mutex = @mutexes[second_id]\n\n    first_mutex.synchronize do\n      second_mutex.synchronize do\n        if @accounts[from_id] >= amount\n          @accounts[from_id] -= amount\n          @accounts[to_id] += amount\n          puts \"Transferred #{amount} from #{from_id} to #{to_id}\"\n          true\n        else\n          puts \"Insufficient funds in #{from_id}\"\n          false\n        end\n      end\n    end\n  end\n\n  def transfer_with_timeout(from_id, to_id, amount, timeout = 1.0)\n    first_id, second_id = [from_id, to_id].sort\n    first_mutex = @mutexes[first_id]\n    second_mutex = @mutexes[second_id]\n\n    start_time = Time.now\n\n    if first_mutex.try_lock\n      begin\n        # Try to get second lock with timeout\n        while !second_mutex.try_lock\n          if Time.now - start_time > timeout\n            puts \"Transfer timeout: #{from_id} -> #{to_id}\"\n            return false\n          end\n          sleep(0.001)\n        end\n\n        begin\n          if @accounts[from_id] >= amount\n            @accounts[from_id] -= amount\n            @accounts[to_id] += amount\n            puts \"Transferred #{amount} from #{from_id} to #{to_id}\"\n            true\n          else\n            false\n          end\n        ensure\n          second_mutex.unlock\n        end\n      ensure\n        first_mutex.unlock\n      end\n    else\n      puts \"Could not acquire first lock: #{first_id}\"\n      false\n    end\n  end\n\n  def balance(id)\n    @mutexes[id].synchronize { @accounts[id] }\n  end\nend\n\n# Demo\nbank = DeadlockSafeTransfer.new\nbank.create_account('A', 1000)\nbank.create_account('B', 800)\nbank.create_account('C', 600)\n\n# Concurrent transfers that could cause deadlock with naive locking\nthreads = []\nthreads << Thread.new { bank.transfer_safe('A', 'B', 100) }\nthreads << Thread.new { bank.transfer_safe('B', 'A', 50) }\nthreads << Thread.new { bank.transfer_safe('B', 'C', 200) }\nthreads << Thread.new { bank.transfer_safe('C', 'A', 150) }\n\nthreads.each(&:join)\n\nputs \"Final balances:\"\nputs \"A: #{bank.balance('A')}\"\nputs \"B: #{bank.balance('B')}\"\nputs \"C: #{bank.balance('C')}\"\n"})}),"\n",(0,r.jsx)(e.h2,{id:"ph\u1ea7n-4-expert-level---k\u1ef9-thu\u1eadt-chuy\xean-gia",children:"Ph\u1ea7n 4: Expert Level - K\u1ef9 Thu\u1eadt Chuy\xean Gia"}),"\n",(0,r.jsx)(e.h3,{id:"41-lock-striping---sharded-mutex-pool",children:"4.1 Lock Striping - Sharded Mutex Pool"}),"\n",(0,r.jsx)(e.p,{children:"\u0110\u1ec3 t\u0103ng throughput, chia resource th\xe0nh nhi\u1ec1u shard v\u1edbi mutex ri\xeang:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'zlib\'\n\nclass ShardedHashMap\n  SHARD_COUNT = 16\n\n  def initialize\n    @shards = Array.new(SHARD_COUNT) { {} }\n    @mutexes = Array.new(SHARD_COUNT) { Mutex.new }\n  end\n\n  def put(key, value)\n    idx = shard_index(key)\n    @mutexes[idx].synchronize do\n      @shards[idx][key] = value\n    end\n  end\n\n  def get(key)\n    idx = shard_index(key)\n    @mutexes[idx].synchronize do\n      @shards[idx][key]\n    end\n  end\n\n  def delete(key)\n    idx = shard_index(key)\n    @mutexes[idx].synchronize do\n      @shards[idx].delete(key)\n    end\n  end\n\n  def size\n    total = 0\n    @mutexes.each_with_index do |mutex, idx|\n      mutex.synchronize do\n        total += @shards[idx].size\n      end\n    end\n    total\n  end\n\n  # Atomic increment operation\n  def increment(key, amount = 1)\n    idx = shard_index(key)\n    @mutexes[idx].synchronize do\n      @shards[idx][key] = (@shards[idx][key] || 0) + amount\n    end\n  end\n\n  def keys\n    all_keys = []\n    @mutexes.each_with_index do |mutex, idx|\n      mutex.synchronize do\n        all_keys.concat(@shards[idx].keys)\n      end\n    end\n    all_keys\n  end\n\n  private\n\n  def shard_index(key)\n    Zlib.crc32(key.to_s) % SHARD_COUNT\n  end\nend\n\n# Performance test\ndef benchmark_sharded_map\n  map = ShardedHashMap.new\n  \n  puts "Testing concurrent writes..."\n  start_time = Time.now\n  \n  threads = 8.times.map do |thread_id|\n    Thread.new do\n      1000.times do |i|\n        key = "thread_#{thread_id}_item_#{i}"\n        map.put(key, "value_#{i}")\n      end\n    end\n  end\n  \n  threads.each(&:join)\n  \n  end_time = Time.now\n  puts "Wrote 8000 items in #{(end_time - start_time).round(3)}s"\n  puts "Final size: #{map.size}"\n  \n  # Test concurrent increments\n  puts "\\nTesting concurrent increments..."\n  start_time = Time.now\n  \n  threads = 10.times.map do\n    Thread.new do\n      1000.times do |i|\n        map.increment("counter_#{i % 100}")\n      end\n    end\n  end\n  \n  threads.each(&:join)\n  \n  end_time = Time.now\n  puts "Performed 10000 increments in #{(end_time - start_time).round(3)}s"\nend\n\nbenchmark_sharded_map\n'})}),"\n",(0,r.jsx)(e.h3,{id:"42-fair-fifo-mutex",children:"4.2 Fair FIFO Mutex"}),"\n",(0,r.jsx)(e.p,{children:"\u0110\u1ea3m b\u1ea3o fairness b\u1eb1ng FIFO queue:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass FairMutex\n  def initialize\n    @queue = []\n    @cv = ConditionVariable.new\n    @lock = Mutex.new\n    @owner = nil\n  end\n\n  def synchronize\n    thread_id = Thread.current.object_id\n    \n    @lock.synchronize do\n      # Add to queue\n      @queue << thread_id\n      \n      # Wait until it\'s our turn\n      while @queue.first != thread_id || @owner\n        @cv.wait(@lock)\n      end\n      \n      # We got the lock\n      @owner = thread_id\n    end\n\n    begin\n      yield\n    ensure\n      @lock.synchronize do\n        @owner = nil\n        @queue.shift\n        @cv.broadcast  # Wake up all waiting threads\n      end\n    end\n  end\n\n  def queue_length\n    @lock.synchronize { @queue.length }\n  end\nend\n\n# Demo fairness\ndef demonstrate_fairness\n  fair_mutex = FairMutex.new\n  results = []\n  results_mutex = Mutex.new\n  \n  threads = 10.times.map do |i|\n    Thread.new do\n      fair_mutex.synchronize do\n        timestamp = Time.now.to_f\n        thread_info = "Thread #{i} acquired lock at #{timestamp}"\n        \n        results_mutex.synchronize do\n          results << { thread: i, time: timestamp }\n        end\n        \n        puts thread_info\n        sleep(0.1)  # Hold lock briefly\n      end\n    end\n  end\n  \n  threads.each(&:join)\n  \n  # Verify FIFO order\n  puts "\\nVerifying FIFO order:"\n  results.sort_by! { |r| r[:time] }\n  results.each_with_index do |result, index|\n    puts "Position #{index}: Thread #{result[:thread]}"\n  end\nend\n\ndemonstrate_fairness\n'})}),"\n",(0,r.jsx)(e.h3,{id:"43-custom-reentrant-mutex",children:"4.3 Custom Reentrant Mutex"}),"\n",(0,r.jsx)(e.p,{children:"T\u1ef1 implement reentrant mutex v\u1edbi ownership tracking:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass CustomReentrantMutex\n  def initialize\n    @owner = nil\n    @depth = 0\n    @cv = ConditionVariable.new\n    @lock = Mutex.new\n  end\n\n  def synchronize\n    acquire\n    begin\n      yield\n    ensure\n      release\n    end\n  end\n\n  def acquire\n    current_thread = Thread.current\n    \n    @lock.synchronize do\n      if @owner == current_thread\n        # Same thread, just increment depth\n        @depth += 1\n      else\n        # Different thread, wait until available\n        while @owner\n          @cv.wait(@lock)\n        end\n        @owner = current_thread\n        @depth = 1\n      end\n    end\n  end\n\n  def release\n    current_thread = Thread.current\n    \n    @lock.synchronize do\n      raise "Not owner" unless @owner == current_thread\n      \n      @depth -= 1\n      if @depth == 0\n        @owner = nil\n        @cv.signal\n      end\n    end\n  end\n\n  def owned_by_current_thread?\n    @lock.synchronize { @owner == Thread.current }\n  end\n\n  def lock_depth\n    @lock.synchronize { @owner == Thread.current ? @depth : 0 }\n  end\nend\n\n# Demo reentrant behavior\nclass ReentrantExample\n  def initialize\n    @mutex = CustomReentrantMutex.new\n    @value = 0\n  end\n\n  def method_a\n    @mutex.synchronize do\n      puts "Method A: depth = #{@mutex.lock_depth}"\n      @value += 1\n      method_b  # Nested call\n    end\n  end\n\n  def method_b\n    @mutex.synchronize do\n      puts "Method B: depth = #{@mutex.lock_depth}"\n      @value += 10\n      method_c  # Another nested call\n    end\n  end\n\n  def method_c\n    @mutex.synchronize do\n      puts "Method C: depth = #{@mutex.lock_depth}"\n      @value += 100\n    end\n  end\n\n  def value\n    @mutex.synchronize { @value }\n  end\nend\n\nexample = ReentrantExample.new\nexample.method_a\nputs "Final value: #{example.value}"  # Should be 111\n'})}),"\n",(0,r.jsx)(e.h3,{id:"44-thread-pool-with-work-stealing",children:"4.4 Thread Pool With Work Stealing"}),"\n",(0,r.jsx)(e.p,{children:"Advanced pattern cho high-performance concurrent processing:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'require \'thread\'\n\nclass WorkStealingThreadPool\n  def initialize(size = 4)\n    @size = size\n    @queues = Array.new(size) { Queue.new }\n    @workers = []\n    @shutdown = false\n    @mutex = Mutex.new\n    \n    start_workers\n  end\n\n  def submit(task)\n    return if @shutdown\n    \n    # Find queue with least work\n    min_queue = @queues.min_by(&:size)\n    min_queue << task\n  end\n\n  def shutdown\n    @mutex.synchronize do\n      @shutdown = true\n      @size.times { |i| @queues[i] << :shutdown }\n    end\n    \n    @workers.each(&:join)\n  end\n\n  private\n\n  def start_workers\n    @workers = @size.times.map do |worker_id|\n      Thread.new { worker_loop(worker_id) }\n    end\n  end\n\n  def worker_loop(worker_id)\n    my_queue = @queues[worker_id]\n    \n    loop do\n      task = get_task(worker_id, my_queue)\n      \n      case task\n      when :shutdown\n        break\n      when Proc\n        begin\n          task.call\n        rescue => e\n          puts "Error in worker #{worker_id}: #{e.message}"\n        end\n      end\n    end\n    \n    puts "Worker #{worker_id} shutting down"\n  end\n\n  def get_task(worker_id, my_queue)\n    # Try own queue first\n    begin\n      return my_queue.pop(true)  # Non-blocking\n    rescue ThreadError\n      # Queue empty, try work stealing\n    end\n    \n    # Try stealing from other queues\n    other_queues = @queues.each_with_index.reject { |_, i| i == worker_id }\n    other_queues.each do |queue, _|\n      begin\n        return queue.pop(true)\n      rescue ThreadError\n        # This queue is also empty\n      end\n    end\n    \n    # All queues empty, block on own queue\n    my_queue.pop\n  end\nend\n\n# Demo\npool = WorkStealingThreadPool.new(4)\n\n# Submit various tasks\n20.times do |i|\n  pool.submit(proc do\n    puts "Processing task #{i} on thread #{Thread.current.object_id}"\n    sleep(rand(0.1..0.5))  # Simulate work\n    puts "Completed task #{i}"\n  end)\nend\n\nsleep(3)  # Let tasks complete\npool.shutdown\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices-v\xe0-l\u01b0u-\xfd",children:"Best Practices v\xe0 L\u01b0u \xdd"}),"\n",(0,r.jsx)(e.h3,{id:"1-tr\xe1nh-common-pitfalls",children:"1. Tr\xe1nh Common Pitfalls"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:"# \u274c Tr\xe1nh: Nested locks c\xf3 th\u1ec3 g\xe2y deadlock\ndef bad_nested_locks\n  @lock1.synchronize do\n    @lock2.synchronize do\n      # Dangerous if another thread locks in reverse order\n    end\n  end\nend\n\n# \u2705 T\u1ed1t: Ordered locking\ndef good_ordered_locks\n  first, second = [@lock1, @lock2].sort_by(&:object_id)\n  first.synchronize do\n    second.synchronize do\n      # Safe\n    end\n  end\nend\n\n# \u274c Tr\xe1nh: Gi\u1eef lock qu\xe1 l\xe2u\ndef bad_long_lock\n  @mutex.synchronize do\n    expensive_network_call  # Blocks other threads unnecessarily\n  end\nend\n\n# \u2705 T\u1ed1t: Minimize lock time\ndef good_short_lock\n  data = expensive_network_call\n  @mutex.synchronize do\n    @shared_data = data  # Quick update\n  end\nend\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-performance-tips",children:"2. Performance Tips"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Lock granularity"}),": S\u1eed d\u1ee5ng fine-grained locks khi c\xf3 th\u1ec3"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Lock-free algorithms"}),": C\xe2n nh\u1eafc atomic operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Thread pool"}),": T\xe1i s\u1eed d\u1ee5ng threads thay v\xec t\u1ea1o m\u1edbi"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Work stealing"}),": C\xe2n b\u1eb1ng t\u1ea3i gi\u1eefa c\xe1c threads"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"3-debugging-concurrent-code",children:"3. Debugging Concurrent Code"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ruby",children:'class DebuggableMutex\n  def initialize(name)\n    @name = name\n    @mutex = Mutex.new\n    @owner = nil\n    @acquired_at = nil\n  end\n\n  def synchronize\n    puts "[#{Time.now}] #{Thread.current.object_id} waiting for #{@name}"\n    \n    @mutex.synchronize do\n      @owner = Thread.current.object_id\n      @acquired_at = Time.now\n      puts "[#{@acquired_at}] #{@owner} acquired #{@name}"\n      \n      begin\n        yield\n      ensure\n        duration = Time.now - @acquired_at\n        puts "[#{Time.now}] #{@owner} released #{@name} (held for #{duration.round(3)}s)"\n        @owner = nil\n        @acquired_at = nil\n      end\n    end\n  end\nend\n'})}),"\n",(0,r.jsx)(e.h2,{id:"k\u1ebft-lu\u1eadn",children:"K\u1ebft Lu\u1eadn"}),"\n",(0,r.jsx)(e.p,{children:"Concurrency trong Ruby l\xe0 m\u1ed9t ch\u1ee7 \u0111\u1ec1 ph\u1ee9c t\u1ea1p nh\u01b0ng c\u1ef1c k\u1ef3 quan tr\u1ecdng. T\u1eeb nh\u1eefng kh\xe1i ni\u1ec7m c\u01a1 b\u1ea3n v\u1ec1 Mutex \u0111\u1ebfn c\xe1c k\u1ef9 thu\u1eadt n\xe2ng cao nh\u01b0 lock striping v\xe0 fair mutexes, m\u1ed7i technique \u0111\u1ec1u c\xf3 use case ri\xeang."}),"\n",(0,r.jsx)(e.h3,{id:"nh\u1eefng-\u0111i\u1ec3m-ch\xednh-c\u1ea7n-nh\u1edb",children:"Nh\u1eefng \u0111i\u1ec3m ch\xednh c\u1ea7n nh\u1edb:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"C\u01a1 b\u1ea3n"}),": S\u1eed d\u1ee5ng ",(0,r.jsx)(e.code,{children:"Mutex#synchronize"})," \u0111\u1ec3 b\u1ea3o v\u1ec7 critical sections"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Trung c\u1ea5p"}),": ",(0,r.jsx)(e.code,{children:"ConditionVariable"})," cho thread coordination, ",(0,r.jsx)(e.code,{children:"try_lock"})," cho non-blocking"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"N\xe2ng cao"}),": ",(0,r.jsx)(e.code,{children:"Monitor"})," cho reentrant locks, ordered locking \u0111\u1ec3 tr\xe1nh deadlock"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Expert"}),": Lock striping cho performance, custom implementations cho special needs"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"khi-n\xe0o-s\u1eed-d\u1ee5ng-g\xec",children:"Khi n\xe0o s\u1eed d\u1ee5ng g\xec:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Simple shared state"}),": ",(0,r.jsx)(e.code,{children:"Mutex#synchronize"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Producer-consumer"}),": ",(0,r.jsx)(e.code,{children:"ConditionVariable"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"High contention"}),": Lock striping ho\u1eb7c lock-free algorithms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Nested locking"}),": ",(0,r.jsx)(e.code,{children:"Monitor"})," ho\u1eb7c custom reentrant mutex"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fairness required"}),": Custom FIFO mutex"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"l\u1eddi-khuy\xean-cu\u1ed1i",children:"L\u1eddi khuy\xean cu\u1ed1i:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["B\u1eaft \u0111\u1ea7u \u0111\u01a1n gi\u1ea3n v\u1edbi ",(0,r.jsx)(e.code,{children:"Mutex#synchronize"})]}),"\n",(0,r.jsx)(e.li,{children:"Profile tr\u01b0\u1edbc khi optimize"}),"\n",(0,r.jsx)(e.li,{children:"Test thoroughly v\u1edbi concurrent workloads"}),"\n",(0,r.jsx)(e.li,{children:"Document thread safety assumptions"}),"\n",(0,r.jsx)(e.li,{children:"Consider alternatives nh\u01b0 Actor model (Celluloid) ho\u1eb7c async programming"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Concurrency kh\xf4ng d\u1ec5, nh\u01b0ng v\u1edbi nh\u1eefng k\u1ef9 thu\u1eadt n\xe0y, b\u1ea1n c\xf3 th\u1ec3 x\xe2y d\u1ef1ng nh\u1eefng \u1ee9ng d\u1ee5ng Ruby hi\u1ec7u su\u1ea5t cao v\xe0 thread-safe! \ud83d\ude80"})]})}function l(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},65404:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>d});var i=t(36672);const r={},o=i.createContext(r);function a(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);