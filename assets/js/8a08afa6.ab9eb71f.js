"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[5466],{43247:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"ruby/csv/expert/csv_schema_structs","title":"csv_schema_structs","description":"\ud83d\udee0\ufe0f Schema-driven Parsing with Dry::Struct Coercions","source":"@site/docs/ruby/csv/expert/csv_schema_structs.md","sourceDirName":"ruby/csv/expert","slug":"/ruby/csv/expert/csv_schema_structs","permalink":"/keep-being-human-dev/docs/ruby/csv/expert/csv_schema_structs","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/csv/expert/csv_schema_structs.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"csv_random_access_indexing","permalink":"/keep-being-human-dev/docs/ruby/csv/expert/csv_random_access_indexing"},"next":{"title":"custom_csv_writing","permalink":"/keep-being-human-dev/docs/ruby/csv/middle/custom_csv_writing"}}');var n=r(23420),c=r(65404);const a={},i=void 0,o={},u=[{value:"\ud83d\udee0\ufe0f Schema-driven Parsing with Dry::Struct Coercions",id:"\ufe0f-schema-driven-parsing-with-drystruct-coercions",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"\ufe0f-schema-driven-parsing-with-drystruct-coercions",children:"\ud83d\udee0\ufe0f Schema-driven Parsing with Dry::Struct Coercions"}),"\n",(0,n.jsx)(t.p,{children:"Enforce strict schemas by combining Ruby CSV converters with Dry::Struct to map each row to a typed struct. This guarantees data integrity and leverages Coercible types for automatic casting."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ruby",children:"require 'csv'\nrequire 'dry-struct'\nmodule Types\n  include Dry.Types()\nend\nclass Transaction < Dry::Struct\n  attribute :id,     Types::Coercible::Integer\n  attribute :amount, Types::Coercible::Float\n  attribute :date,   Types::Params::Date\nend\n\nrecords = CSV.read('transactions.csv', headers: true, converters: [:date]).map do |row|\n  Transaction.new(row.to_hash)\nend\nrecords.each { |tx| puts \"ID: #{tx.id}, Amount: #{tx.amount}, Date: #{tx.date}\" }\n"})})]})}function p(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},65404:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>i});var s=r(36672);const n={},c=s.createContext(n);function a(e){const t=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(c.Provider,{value:t},e.children)}}}]);