"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[14485],{65404:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(36672);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}},66367:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"gems/faraday/middle/timeouts_and_retries","title":"timeouts_and_retries","description":"\u23f1\ufe0f Setting Timeouts and Retries","source":"@site/docs/gems/faraday/middle/timeouts_and_retries.md","sourceDirName":"gems/faraday/middle","slug":"/gems/faraday/middle/timeouts_and_retries","permalink":"/keep-being-human-dev/docs/gems/faraday/middle/timeouts_and_retries","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/faraday/middle/timeouts_and_retries.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_middleware_integration","permalink":"/keep-being-human-dev/docs/gems/faraday/middle/custom_middleware_integration"},"next":{"title":"consistent_percentage_rollout","permalink":"/keep-being-human-dev/docs/gems/flipper/advanced/consistent_percentage_rollout"}}');var i=n(23420),a=n(65404);const s={},o=void 0,d={},u=[{value:"\u23f1\ufe0f Setting Timeouts and Retries",id:"\ufe0f-setting-timeouts-and-retries",level:2}];function c(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"\ufe0f-setting-timeouts-and-retries",children:"\u23f1\ufe0f Setting Timeouts and Retries"}),"\n",(0,i.jsx)(t.p,{children:"Handling intermittent network failures and slow endpoints is crucial for resilient applications. Faraday\u2019s built\u2011in retry middleware and timeout options let you fine\u2011tune how many times to retry failed requests and how long to wait before timing out."}),"\n",(0,i.jsx)(t.p,{children:"Configure timeouts and retry behavior in the connection block:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"require 'faraday'\nrequire 'faraday/retry'\n\nconn = Faraday.new(url: 'https://api.example.com') do |f|\n  # Timeout settings (in seconds)\n  f.options.open_timeout = 2   # connection open timeout\n  f.options.timeout      = 5   # response read timeout\n\n  # Retry middleware configuration\n  f.request :retry, max: 3,                # retry up to 3 times\n                    interval: 0.5,         # initial wait time\n                    interval_randomness: 0.5, # jitter\n                    backoff_factor: 2,     # exponential backoff\n                    retry_statuses: [429, 500, 502, 503, 504]\n\n  f.adapter Faraday.default_adapter\nend\n\nresponse = conn.get('/unstable_endpoint')\nputs \"Status: #{response.status}\", response.body\n"})})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);