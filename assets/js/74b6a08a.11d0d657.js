"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[9964],{4447:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"ruby/networking/advanced/http2_stream_multiplexing","title":"http2_stream_multiplexing","description":"\u26a1 HTTP/2 Stream Multiplexing with the http-2 Gem","source":"@site/docs/ruby/networking/advanced/http2_stream_multiplexing.md","sourceDirName":"ruby/networking/advanced","slug":"/ruby/networking/advanced/http2_stream_multiplexing","permalink":"/keep-being-human-dev/docs/ruby/networking/advanced/http2_stream_multiplexing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/networking/advanced/http2_stream_multiplexing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"eventmachine_async_io","permalink":"/keep-being-human-dev/docs/ruby/networking/advanced/eventmachine_async_io"},"next":{"title":"nonblocking_tcp_socket","permalink":"/keep-being-human-dev/docs/ruby/networking/advanced/nonblocking_tcp_socket"}}');var s=n(23420),r=n(65404);const i={},o=void 0,c={},l=[{value:"\u26a1 HTTP/2 Stream Multiplexing with the <code>http-2</code> Gem",id:"-http2-stream-multiplexing-with-the-http-2-gem",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.h2,{id:"-http2-stream-multiplexing-with-the-http-2-gem",children:["\u26a1 HTTP/2 Stream Multiplexing with the ",(0,s.jsx)(t.code,{children:"http-2"})," Gem"]}),"\n",(0,s.jsxs)(t.p,{children:["Use the ",(0,s.jsx)(t.code,{children:"http-2"})," gem to open a single TCP+TLS connection and multiplex multiple HTTP/2 streams simultaneously. This reduces latency by sending parallel requests over the same socket, while the gem handles framing and stream state management for you."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:"require 'http/2'\nrequire 'socket'\nrequire 'openssl'\n\n# Establish TLS socket\nssl_ctx = OpenSSL::SSL::SSLContext.new(:TLSv1_3)\nsock = TCPSocket.new('api.example.com', 443)\nssl = OpenSSL::SSL::SSLSocket.new(sock, ssl_ctx)\nssl.connect\n\nclient = HTTP2::Client.new\n\n# Hook into the socket\nclient.on(:frame) do |bytes|\n  ssl.write(bytes)\nend\n\n# Read incoming frames\nThread.new do\n  loop do\n    data = ssl.readpartial(1024)\n    client << data\n  end\nend\n\n# Create two concurrent streams\n[\"/stream1\", \"/stream2\"].each do |path|\n  stream = client.new_stream\n  stream.on(:headers) { |h| puts \"Headers: #{h}\" }\n  stream.on(:data)    { |d| puts \"Data: #{d}\" }\n  stream.headers({ ':method' => 'GET', ':path' => path, ':scheme' => 'https', ':authority' => 'api.example.com' }, end_stream: true)\nend\n\n# Flush pending frames\nclient.ping\n"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(36672);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);