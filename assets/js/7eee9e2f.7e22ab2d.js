"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[91895],{12213:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"ruby/constants/advanced/autoload_with_const_missing","title":"autoload_with_const_missing","description":"\ud83d\udd04 Leveraging autoload with const_missing","source":"@site/docs/ruby/constants/advanced/autoload_with_const_missing.md","sourceDirName":"ruby/constants/advanced","slug":"/ruby/constants/advanced/autoload_with_const_missing","permalink":"/keep-being-human-dev/docs/ruby/constants/advanced/autoload_with_const_missing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/constants/advanced/autoload_with_const_missing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"mutex_try_lock","permalink":"/keep-being-human-dev/docs/ruby/concurrency_and_mutexes/middle/mutex_try_lock"},"next":{"title":"dynamic_constants_via_const_set","permalink":"/keep-being-human-dev/docs/ruby/constants/advanced/dynamic_constants_via_const_set"}}');var o=t(23420),a=t(65404);const i={},c=void 0,d={},r=[{value:"\ud83d\udd04 Leveraging <code>autoload</code> with <code>const_missing</code>",id:"-leveraging-autoload-with-const_missing",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h2,{id:"-leveraging-autoload-with-const_missing",children:["\ud83d\udd04 Leveraging ",(0,o.jsx)(n.code,{children:"autoload"})," with ",(0,o.jsx)(n.code,{children:"const_missing"})]}),"\n",(0,o.jsxs)(n.p,{children:["Combine ",(0,o.jsx)(n.code,{children:"Module#autoload"})," with a custom ",(0,o.jsx)(n.code,{children:"const_missing"})," hook to lazily load or generate constants on demand. This pattern helps keep your startup time low while ensuring only the necessary constants are loaded. You can also implement fallbacks if the file path doesn\u2019t exist."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:'module MyApp\n  # Automatically load `MyApp::ServiceX` from "my_app/service_x.rb"\n  autoload :ServiceX, "my_app/service_x"\n\n  def self.const_missing(name)\n    warn "Constant \\\\#{name} not found, attempting dynamic generation..."\n    # e.g., generate a null object or proxy\n    const_set(name, Class.new do\n      def method_missing(m, *args) ; nil ; end\n    end)\n  end\nend\n\n# Usage\nMyApp::ServiceX.new.perform\nMyApp::NonExistentConstant.some_method  # Triggers const_missing\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(36672);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);