"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[21116],{65404:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>d});var t=n(36672);const r={},s=t.createContext(r);function a(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:i},e.children)}},70799:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>d,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"nosql/redis/middle/redis_api_rate_limiter","title":"redis_api_rate_limiter","description":"\u23f1 Implement API rate limiting with Redis and Lua","source":"@site/docs/nosql/redis/middle/redis_api_rate_limiter.md","sourceDirName":"nosql/redis/middle","slug":"/nosql/redis/middle/redis_api_rate_limiter","permalink":"/keep-being-human-dev/docs/nosql/redis/middle/redis_api_rate_limiter","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nosql/redis/middle/redis_api_rate_limiter.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"redis_streams_event_sourcing","permalink":"/keep-being-human-dev/docs/nosql/redis/expert/redis_streams_event_sourcing"},"next":{"title":"redis_cachestore_namespace","permalink":"/keep-being-human-dev/docs/nosql/redis/middle/redis_cachestore_namespace"}}');var r=n(23420),s=n(65404);const a={},d=void 0,o={},l=[{value:"\u23f1 Implement API rate limiting with Redis and Lua",id:"-implement-api-rate-limiting-with-redis-and-lua",level:2}];function c(e){const i={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h2,{id:"-implement-api-rate-limiting-with-redis-and-lua",children:"\u23f1 Implement API rate limiting with Redis and Lua"}),"\n",(0,r.jsx)(i.p,{children:"Throttle API requests per user or IP by using Redis and an atomic Lua script to increment and expire counters. This approach minimizes race conditions and provides precise rate limiting logic within Redis."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ruby",children:"# lib/rate_limiter.rb\nclass RateLimiter\n  LUA_SCRIPT = <<~LUA\n    local current = redis.call('INCR', KEYS[1])\n    if tonumber(current) == 1 then\n      redis.call('PEXPIRE', KEYS[1], ARGV[1])\n    end\n    return current\n  LUA\n\n  def initialize(redis: Redis.new(url: ENV['REDIS_URL']), limit: 100, period_ms: 60_000)\n    @redis = redis\n    @limit = limit\n    @period = period_ms\n  end\n\n  def allowed?(key)\n    count = @redis.eval(LUA_SCRIPT, keys: [key], argv: [@period])\n    count.to_i <= @limit\n  end\nend\n\n# Usage in controller\nbefore_action do\n  limiter = RateLimiter.new\n  head :too_many_requests unless limiter.allowed?(\"rate:#{request.ip}\")\nend\n"})})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);