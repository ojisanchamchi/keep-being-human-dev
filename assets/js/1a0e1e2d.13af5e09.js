"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[87140],{65404:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>i});var a=o(36672);const c={},t=a.createContext(c);function r(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),a.createElement(t.Provider,{value:n},e.children)}},68454:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"gems/geocoder/advanced/geocoder_caching_and_fallback_strategies","title":"geocoder_caching_and_fallback_strategies","description":"\ud83d\udee2\ufe0f Implementing Caching and Fallback Strategies","source":"@site/docs/gems/geocoder/advanced/geocoder_caching_and_fallback_strategies.md","sourceDirName":"gems/geocoder/advanced","slug":"/gems/geocoder/advanced/geocoder_caching_and_fallback_strategies","permalink":"/keep-being-human-dev/docs/gems/geocoder/advanced/geocoder_caching_and_fallback_strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/geocoder/advanced/geocoder_caching_and_fallback_strategies.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"flipper_percentage_rollout","permalink":"/keep-being-human-dev/docs/gems/flipper/middle/flipper_percentage_rollout"},"next":{"title":"polymorphic_geocoding_multiple_models","permalink":"/keep-being-human-dev/docs/gems/geocoder/advanced/polymorphic_geocoding_multiple_models"}}');var c=o(23420),t=o(65404);const r={},i=void 0,s={},d=[{value:"\ud83d\udee2\ufe0f Implementing Caching and Fallback Strategies",id:"\ufe0f-implementing-caching-and-fallback-strategies",level:2}];function l(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"\ufe0f-implementing-caching-and-fallback-strategies",children:"\ud83d\udee2\ufe0f Implementing Caching and Fallback Strategies"}),"\n",(0,c.jsx)(n.p,{children:"For high\u2011volume geocoding or reverse lookups, caching responses in Redis reduces API calls and costs. Configure Geocoder to use Redis and fall back between services:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ruby",children:"# config/initializers/geocoder.rb\nGeocoder.configure(\n  timeout: 5,\n  lookup: :google,\n  api_key: ENV['GOOGLE_GEOCODING_API_KEY'],\n  cache: Redis.new(url: ENV['REDIS_URL']),\n  cache_prefix: 'geocoder:',\n  use_https: true,\n  always_raise: [Geocoder::OverQueryLimitError, Geocoder::RequestDenied],\n  lookup_cache: {\n    fallback: :nominatim,\n    nominatim: {\n      host: 'nominatim.openstreetmap.org',\n      format: 'json'\n    }\n  }\n)\n"})}),"\n",(0,c.jsx)(n.p,{children:"With this setup, Geocoder will:"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["Attempt the Google API and cache the result under ",(0,c.jsx)(n.code,{children:"geocoder:..."})," in Redis."]}),"\n",(0,c.jsx)(n.li,{children:"On quota errors or timeouts, automatically retry using OpenStreetMap\u2019s Nominatim."}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"You can then safely call:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ruby",children:"coords = Geocoder.coordinates('1600 Amphitheatre Parkway, Mountain View, CA')\n"})})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}}}]);