"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[26706],{65404:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(36672);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},90028:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ruby/operators/expert/bitmask_flags_with_operators","title":"bitmask_flags_with_operators","description":"\ud83d\udd27 Bitmask-Based Flags via Bitwise Operators","source":"@site/docs/ruby/operators/expert/bitmask_flags_with_operators.md","sourceDirName":"ruby/operators/expert","slug":"/ruby/operators/expert/bitmask_flags_with_operators","permalink":"/keep-being-human-dev/docs/ruby/operators/expert/bitmask_flags_with_operators","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/operators/expert/bitmask_flags_with_operators.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ternary_operator","permalink":"/keep-being-human-dev/docs/ruby/operators/beginner/ternary_operator"},"next":{"title":"custom_unary_operator_overloads","permalink":"/keep-being-human-dev/docs/ruby/operators/expert/custom_unary_operator_overloads"}}');var r=n(23420),a=n(65404);const o={},i=void 0,d={},c=[{value:"\ud83d\udd27 Bitmask-Based Flags via Bitwise Operators",id:"-bitmask-based-flags-via-bitwise-operators",level:2}];function l(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"-bitmask-based-flags-via-bitwise-operators",children:"\ud83d\udd27 Bitmask-Based Flags via Bitwise Operators"}),"\n",(0,r.jsxs)(t.p,{children:["Implement extensible flag enums using bitwise operators (",(0,r.jsx)(t.code,{children:"|"}),", ",(0,r.jsx)(t.code,{children:"&"}),", ",(0,r.jsx)(t.code,{children:"^"}),", ",(0,r.jsx)(t.code,{children:"~"}),"). This allows clear, performant flag manipulation in domain code."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:'class Flags\n  FLAGS = { read: 0b001, write: 0b010, execute: 0b100 }\n\n  def initialize(mask = 0)\n    @mask = mask\n  end\n\n  FLAGS.each do |name, bit|\n    define_method(name) { (@mask & bit) != 0 }\n    define_method("#{name}=") do |val|\n      @mask = val ? (@mask | bit) : (@mask & ~bit)\n    end\n  end\n\n  def |(other)\n    self.class.new(@mask | other.to_i)\n  end\n\n  def &(other)\n    self.class.new(@mask & other.to_i)\n  end\n\n  def ^(other)\n    self.class.new(@mask ^ other.to_i)\n  end\n\n  def to_i; @mask; end\nend\n\nf1 = Flags.new\nf1.read = true\nf2 = Flags.new\nf2.write = true\ncombined = f1 | f2\nputs combined.to_i    # \u21d2 3 (0b011)\n'})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);