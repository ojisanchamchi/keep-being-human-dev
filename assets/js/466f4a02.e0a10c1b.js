"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[44970],{60759:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"rails/active_record_associations/advanced/self_referential_scopes","title":"self_referential_scopes","description":"\ud83d\udd04 Self-Referential Associations with Scoped Relations","source":"@site/docs/rails/active_record_associations/advanced/self_referential_scopes.md","sourceDirName":"rails/active_record_associations/advanced","slug":"/rails/active_record_associations/advanced/self_referential_scopes","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/advanced/self_referential_scopes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_associations/advanced/self_referential_scopes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"preloading_with_aggregates","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/advanced/preloading_with_aggregates"},"next":{"title":"sti_associations_with_default_scopes","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/advanced/sti_associations_with_default_scopes"}}');var i=n(23420),t=n(65404);const r={},o=void 0,c={},d=[{value:"\ud83d\udd04 Self-Referential Associations with Scoped Relations",id:"-self-referential-associations-with-scoped-relations",level:2}];function l(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h2,{id:"-self-referential-associations-with-scoped-relations",children:"\ud83d\udd04 Self-Referential Associations with Scoped Relations"}),"\n",(0,i.jsx)(s.p,{children:"Define self-referential associations with custom scopes to build powerful relationship graphs (e.g., followers, friends). You can apply conditions on join models to separate accepted vs. pending records. This pattern keeps your user model clean and your queries performant."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ruby",children:"class User < ApplicationRecord\n  has_many :friendships, -> { where(status: 'accepted') },\n           class_name: 'Friendship', foreign_key: 'user_id'\n  has_many :accepted_friends, through: :friendships, source: :friend\n\n  has_many :pending_friendships, -> { where(status: 'pending') },\n           class_name: 'Friendship', foreign_key: 'user_id'\n  has_many :pending_friends, through: :pending_friendships, source: :friend\nend\n\nclass Friendship < ApplicationRecord\n  belongs_to :user\n  belongs_to :friend, class_name: 'User'\nend\n"})})]})}function p(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},65404:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var a=n(36672);const i={},t=a.createContext(i);function r(e){const s=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(t.Provider,{value:s},e.children)}}}]);