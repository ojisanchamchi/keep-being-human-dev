"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[52963],{65404:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>o});var t=n(36672);const r={},s=t.createContext(r);function i(e){const a=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:a},e.children)}},85163:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"ruby/serialization/expert/hybrid_msgpack_json","title":"hybrid_msgpack_json","description":"\ud83d\udd04 Hybrid MessagePack & JSON Schema Fallback for Reliable Data Exchange","source":"@site/docs/ruby/serialization/expert/hybrid_msgpack_json.md","sourceDirName":"ruby/serialization/expert","slug":"/ruby/serialization/expert/hybrid_msgpack_json","permalink":"/keep-being-human-dev/docs/ruby/serialization/expert/hybrid_msgpack_json","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/serialization/expert/hybrid_msgpack_json.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"yaml_serialization","permalink":"/keep-being-human-dev/docs/ruby/serialization/beginner/yaml_serialization"},"next":{"title":"oj_object_hooks","permalink":"/keep-being-human-dev/docs/ruby/serialization/expert/oj_object_hooks"}}');var r=n(23420),s=n(65404);const i={},o=void 0,c={},l=[{value:"\ud83d\udd04 Hybrid MessagePack &amp; JSON Schema Fallback for Reliable Data Exchange",id:"-hybrid-messagepack--json-schema-fallback-for-reliable-data-exchange",level:2}];function d(e){const a={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"-hybrid-messagepack--json-schema-fallback-for-reliable-data-exchange",children:"\ud83d\udd04 Hybrid MessagePack & JSON Schema Fallback for Reliable Data Exchange"}),"\n",(0,r.jsx)(a.p,{children:"In distributed systems, binary formats like MessagePack are ideal for speed, but sometimes you need human-readable fallbacks. Implement a wrapper that tries MessagePack, and if validation against a JSON Schema fails, re-serialize to JSON. This guarantees both performance and debuggability."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-ruby",children:'require \'msgpack\'\nrequire \'json-schema\'\n\nSCHEMA = {\n  "type" => "object",\n  "required" => ["id","payload"],\n  "properties" => {\n    "id" => { "type" => "string" },\n    "payload" => { "type" => "object" }\n  }\n}\n\ndef serialize(data)\n  bin = data.to_msgpack\n  begin\n    JSON::Validator.validate!(SCHEMA, MessagePack.unpack(bin))\n    { format: :msgpack, data: bin }\n  rescue JSON::Schema::ValidationError\n    { format: :json, data: data.to_json }\n  end\nend\n\n# Usage\npacket = { id: "123", payload: { foo: :bar } }\nresult = serialize(packet)\n# result[:format] == :msgpack or :json\n'})})]})}function p(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);