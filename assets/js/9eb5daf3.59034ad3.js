"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[97822],{54517:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"ruby/directory_management/advanced/recursive_traversal_find","title":"recursive_traversal_find","description":"\ud83d\udd0d Efficient Recursive Directory Traversal with Find and Pathname","source":"@site/docs/ruby/directory_management/advanced/recursive_traversal_find.md","sourceDirName":"ruby/directory_management/advanced","slug":"/ruby/directory_management/advanced/recursive_traversal_find","permalink":"/keep-being-human-dev/docs/ruby/directory_management/advanced/recursive_traversal_find","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/directory_management/advanced/recursive_traversal_find.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"atomic_directory_swap","permalink":"/keep-being-human-dev/docs/ruby/directory_management/advanced/atomic_directory_swap"},"next":{"title":"dir_list_and_filter","permalink":"/keep-being-human-dev/docs/ruby/directory_management/beginner/dir_list_and_filter"}}');var a=r(23420),i=r(65404);const s={},d=void 0,o={},c=[{value:"\ud83d\udd0d Efficient Recursive Directory Traversal with Find and Pathname",id:"-efficient-recursive-directory-traversal-with-find-and-pathname",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"-efficient-recursive-directory-traversal-with-find-and-pathname",children:"\ud83d\udd0d Efficient Recursive Directory Traversal with Find and Pathname"}),"\n",(0,a.jsxs)(n.p,{children:["When you need to walk a complex directory tree, Ruby\u2019s ",(0,a.jsx)(n.code,{children:"Find"})," module paired with ",(0,a.jsx)(n.code,{children:"Pathname"})," gives you both speed and expressive power. This approach helps you skip unwanted paths (like ",(0,a.jsx)(n.code,{children:".git"}),"), resolve symlinks safely, and filter by file type in a single pass."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"require 'find'\nrequire 'pathname'\n\nroot = Pathname.new('/path/to/project')\nignored_dirs = %w[.git node_modules vendor]\n\nFind.find(root) do |path_str|\n  path = Pathname.new(path_str)\n\n  # Skip unwanted directories early\n  if path.directory? && ignored_dirs.include?(path.basename.to_s)\n    Find.prune\n  end\n\n  # Only process real files, not broken symlinks\n  next unless path.file? && path.realpath.file?\n\n  # Example: pick up only Ruby files\n  if path.extname == '.rb'\n    puts \"Found Ruby file: #{path.relative_path_from(root)}\"\n  end\nend\n"})}),"\n",(0,a.jsx)(n.p,{children:"This pattern scales to millions of files, avoids infinite loops from symlink cycles, and keeps your code readable and maintainable."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},65404:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(36672);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);