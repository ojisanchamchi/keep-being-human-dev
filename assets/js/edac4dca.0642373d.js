"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[64324],{10313:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"ruby/xml/advanced/xpath_with_namespaces","title":"xpath_with_namespaces","description":"\ud83c\udf10 Manipulating Namespaced XML with Advanced XPath","source":"@site/docs/ruby/xml/advanced/xpath_with_namespaces.md","sourceDirName":"ruby/xml/advanced","slug":"/ruby/xml/advanced/xpath_with_namespaces","permalink":"/keep-being-human-dev/docs/ruby/xml/advanced/xpath_with_namespaces","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/xml/advanced/xpath_with_namespaces.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"sax_streaming_large_xml","permalink":"/keep-being-human-dev/docs/ruby/xml/advanced/sax_streaming_large_xml"},"next":{"title":"basic_parsing_with_rexml","permalink":"/keep-being-human-dev/docs/ruby/xml/beginner/basic_parsing_with_rexml"}}');var s=a(23420),c=a(65404);const i={},r=void 0,d={},o=[{value:"\ud83c\udf10 Manipulating Namespaced XML with Advanced XPath",id:"-manipulating-namespaced-xml-with-advanced-xpath",level:2}];function l(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"-manipulating-namespaced-xml-with-advanced-xpath",children:"\ud83c\udf10 Manipulating Namespaced XML with Advanced XPath"}),"\n",(0,s.jsx)(n.p,{children:"XML with multiple namespaces can be tricky to query. Nokogiri lets you register namespace prefixes and then use them in XPath expressions. This is invaluable when extracting values from deeply nested, namespaced documents."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"require 'nokogiri'\nxml = <<-XML\n<root xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n  <dc:record>\n    <dc:title>Advanced Ruby XML</dc:title>\n    <dc:date>2024-01-01</dc:date>\n  </dc:record>\n</root>\nXML\n\ndoc = Nokogiri::XML(xml)\n# Register the namespace prefix 'dc'\ndoc.remove_namespaces! # optional: flatten if you only have one, but to keep:\n# doc.root.add_namespace('dc', 'http://purl.org/dc/elements/1.1/')\n\ntitles = doc.xpath('//dc:record/dc:title', 'dc' => 'http://purl.org/dc/elements/1.1/')\ntitles.each do |node|\n  puts \"Title: #{node.text}\"\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"Key points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always provide the correct URI for each prefix."}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"doc.remove_namespaces!"})," when you need a quick namespace-agnostic parse."]}),"\n",(0,s.jsx)(n.li,{children:"Complex XPath queries can include predicates, functions, and axes even with namespaces."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var t=a(36672);const s={},c=t.createContext(s);function i(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);