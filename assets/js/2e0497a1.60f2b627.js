"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[28746],{64293:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"ruby/matrix/advanced/lu_caching_solver","title":"lu_caching_solver","description":"\ud83e\uddee Efficient Batch Solving with LU Caching","source":"@site/docs/ruby/matrix/advanced/lu_caching_solver.md","sourceDirName":"ruby/matrix/advanced","slug":"/ruby/matrix/advanced/lu_caching_solver","permalink":"/keep-being-human-dev/docs/ruby/matrix/advanced/lu_caching_solver","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/matrix/advanced/lu_caching_solver.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"deep_clone_objects","permalink":"/keep-being-human-dev/docs/ruby/marshal/middle/deep_clone_objects"},"next":{"title":"numo_linalg_svd","permalink":"/keep-being-human-dev/docs/ruby/matrix/advanced/numo_linalg_svd"}}');var a=t(23420),r=t(65404);const s={},o=void 0,c={},u=[{value:"\ud83e\uddee Efficient Batch Solving with LU Caching",id:"-efficient-batch-solving-with-lu-caching",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"-efficient-batch-solving-with-lu-caching",children:"\ud83e\uddee Efficient Batch Solving with LU Caching"}),"\n",(0,a.jsx)(n.p,{children:"When you need to solve multiple systems Ax = b with the same coefficient matrix, decomposing A each time is wasteful. Use Matrix#lu to decompose once into L, U and a permutation vector, then implement simple forward/backward substitution for each new right\u2010hand side."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"require 'matrix'\n\nclass LUCacheSolver\n  def initialize(a)\n    @l, @u, @perm, _ = a.lu\n  end\n\n  def solve(b)\n    # Apply row permutations\n    bp = Vector.elements(@perm.map { |i| b[i] })\n    # Forward substitution Ly = bp\n    y = forward_substitution(@l, bp)\n    # Backward substitution Ux = y\n    backward_substitution(@u, y)\n  end\n\n  private\n\n  def forward_substitution(l, b)\n    n = b.size\n    y = Array.new(n)\n    (0...n).each do |i|\n      sum = (0...i).inject(0) { |s, j| s + l[i, j] * y[j] }\n      y[i] = (b[i] - sum) / l[i, i]\n    end\n    Vector[*y]\n  end\n\n  def backward_substitution(u, y)\n    n = y.size\n    x = Array.new(n)\n    (n-1).downto(0) do |i|\n      sum = ((i+1)...n).inject(0) { |s, j| s + u[i, j] * x[j] }\n      x[i] = (y[i] - sum) / u[i, i]\n    end\n    Vector[*x]\n  end\nend\n\n# Usage example\na = Matrix[[4.0, 2.0, 0.0], [2.0, 4.0, 2.0], [0.0, 2.0, 4.0]]\nsolver = LUCacheSolver.new(a)\nb1 = Vector[2.0, 4.0, 6.0]\nb2 = Vector[1.0, 0.0, 1.0]\n\nputs solver.solve(b1)  # => solution for first RHS\nputs solver.solve(b2)  # => solution for second RHS\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(36672);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);