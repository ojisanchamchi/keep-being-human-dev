"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[93240],{5577:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rails/active_record_callbacks/expert/around_commit_transaction","title":"around_commit_transaction","description":"\ud83d\ude80 Leveraging around_commit for Transaction-Dependent Logic","source":"@site/docs/rails/active_record_callbacks/expert/around_commit_transaction.md","sourceDirName":"rails/active_record_callbacks/expert","slug":"/rails/active_record_callbacks/expert/around_commit_transaction","permalink":"/keep-being-human-dev/docs/rails/active_record_callbacks/expert/around_commit_transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_callbacks/expert/around_commit_transaction.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"abort_before_destroy","permalink":"/keep-being-human-dev/docs/rails/active_record_callbacks/expert/abort_before_destroy"},"next":{"title":"async_callbacks","permalink":"/keep-being-human-dev/docs/rails/active_record_callbacks/expert/async_callbacks"}}');var a=t(23420),c=t(65404);const o={},i=void 0,s={},d=[{value:"\ud83d\ude80 Leveraging <code>around_commit</code> for Transaction-Dependent Logic",id:"-leveraging-around_commit-for-transaction-dependent-logic",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h2,{id:"-leveraging-around_commit-for-transaction-dependent-logic",children:["\ud83d\ude80 Leveraging ",(0,a.jsx)(n.code,{children:"around_commit"})," for Transaction-Dependent Logic"]}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"around_commit"})," to wrap logic that must run only after a successful DB transaction. This ensures that side effects (e.g., external API calls) occur only when the transaction actually commits. You can yield to the block to execute the transaction and then perform post-commit work."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Order < ApplicationRecord\n  around_commit :notify_shipping_service, on: :create\n\n  private\n\n  def notify_shipping_service\n    yield  # runs the DB transaction\n    ShippingService.enqueue(self.id)\n  end\nend\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This pattern avoids race conditions by deferring external calls until after commit. You can also use ",(0,a.jsx)(n.code,{children:"on: :update"})," or ",(0,a.jsx)(n.code,{children:":destroy"})," to scope it further."]})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(36672);const a={},c=r.createContext(a);function o(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);