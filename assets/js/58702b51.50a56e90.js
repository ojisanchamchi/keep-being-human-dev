"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[84207],{65404:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var s=n(36672);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},75642:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>i});const s=JSON.parse('{"id":"gems/webmock/advanced/stub_dynamic_request_patterns","title":"stub_dynamic_request_patterns","description":"\ud83d\udd25 Dynamic URL Pattern Stubbing","source":"@site/docs/gems/webmock/advanced/stub_dynamic_request_patterns.md","sourceDirName":"gems/webmock/advanced","slug":"/gems/webmock/advanced/stub_dynamic_request_patterns","permalink":"/keep-being-human-dev/docs/gems/webmock/advanced/stub_dynamic_request_patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/webmock/advanced/stub_dynamic_request_patterns.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_request_matchers_and_callbacks","permalink":"/keep-being-human-dev/docs/gems/webmock/advanced/custom_request_matchers_and_callbacks"},"next":{"title":"stub_get_requests","permalink":"/keep-being-human-dev/docs/gems/webmock/beginner/stub_get_requests"}}');var r=n(23420),a=n(65404);const o={},c=void 0,u={},i=[{value:"\ud83d\udd25 Dynamic URL Pattern Stubbing",id:"-dynamic-url-pattern-stubbing",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"-dynamic-url-pattern-stubbing",children:"\ud83d\udd25 Dynamic URL Pattern Stubbing"}),"\n",(0,r.jsx)(t.p,{children:"When testing APIs that include dynamic segments in URLs (e.g., IDs or timestamps), you can use regular expressions to stub multiple endpoints with one rule. This prevents repetitive stubs and keeps tests DRY. You can capture segments to use in your response logic."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"require 'webmock/rspec'\n\nRSpec.describe \"Dynamic endpoint stubs\" do\n  include WebMock::API\n\n  before do\n    # Stub any GET to /users/<number>/posts\n    stub_request(:get, %r{https://api\\.example\\.com/users/\\d+/posts})\n      .to_return do |request|\n        user_id = request.uri.path.split('/')[2]\n        {\n          status: 200,\n          body: { user_id: user_id, posts: [] }.to_json,\n          headers: { 'Content-Type' => 'application/json' }\n        }\n      end\n  end\n\n  it \"returns a tailored response based on the captured user ID\" do\n    response = Net::HTTP.get(URI('https://api.example.com/users/42/posts'))\n    data = JSON.parse(response)\n\n    expect(data['user_id']).to eq('42')\n    expect(data['posts']).to eq([])\n  end\nend\n"})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);