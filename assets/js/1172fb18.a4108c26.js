"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[73589],{65404:(e,o,t)=>{t.d(o,{R:()=>r,x:()=>i});var c=t(36672);const n={},s=c.createContext(n);function r(e){const o=c.useContext(s);return c.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),c.createElement(s.Provider,{value:o},e.children)}},91133:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>l});const c=JSON.parse('{"id":"rails/active_record_associations/expert/polymorphic_counter_cache","title":"polymorphic_counter_cache","description":"\u2699\ufe0f Polymorphic Counter Cache with Custom Column","source":"@site/docs/rails/active_record_associations/expert/polymorphic_counter_cache.md","sourceDirName":"rails/active_record_associations/expert","slug":"/rails/active_record_associations/expert/polymorphic_counter_cache","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/expert/polymorphic_counter_cache","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_associations/expert/polymorphic_counter_cache.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"multi_level_through_alias","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/expert/multi_level_through_alias"},"next":{"title":"scoped_polymorphic_association_conditions","permalink":"/keep-being-human-dev/docs/rails/active_record_associations/expert/scoped_polymorphic_association_conditions"}}');var n=t(23420),s=t(65404);const r={},i=void 0,a={},l=[{value:"\u2699\ufe0f Polymorphic Counter Cache with Custom Column",id:"\ufe0f-polymorphic-counter-cache-with-custom-column",level:2}];function u(e){const o={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h2,{id:"\ufe0f-polymorphic-counter-cache-with-custom-column",children:"\u2699\ufe0f Polymorphic Counter Cache with Custom Column"}),"\n",(0,n.jsx)(o.p,{children:"Implement a counter cache on polymorphic associations by providing a custom column name and callback override. This optimizes reads in high-traffic systems."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ruby",children:"class Comment < ApplicationRecord\n  belongs_to :commentable, polymorphic: true, counter_cache: :comments_count\nend\n\nclass Post < ApplicationRecord\n  # Ensure comments_count integer column exists\n  has_many :comments, as: :commentable\nend\n"})}),"\n",(0,n.jsx)(o.p,{children:"Add migrations to maintain the custom counter and manually reset caches with:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-ruby",children:"def reset_comments_count\n  Post.find_each { |p| Post.reset_counters(p.id, :comments) }\nend\n"})})]})}function m(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);