"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[90194],{65404:(e,o,t)=>{t.d(o,{R:()=>c,x:()=>a});var n=t(36672);const s={},r=n.createContext(s);function c(e){const o=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(r.Provider,{value:o},e.children)}},69939:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>c,metadata:()=>n,toc:()=>i});const n=JSON.parse('{"id":"ruby/methods/middle/symbol_to_proc","title":"symbol_to_proc","description":"\u2728 Converting Methods to Procs with Symbol#to_proc","source":"@site/docs/ruby/methods/middle/symbol_to_proc.md","sourceDirName":"ruby/methods/middle","slug":"/ruby/methods/middle/symbol_to_proc","permalink":"/keep-being-human-dev/docs/ruby/methods/middle/symbol_to_proc","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/methods/middle/symbol_to_proc.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"splat_and_double_splat","permalink":"/keep-being-human-dev/docs/ruby/methods/middle/splat_and_double_splat"},"next":{"title":"tap_chaining","permalink":"/keep-being-human-dev/docs/ruby/methods/middle/tap_chaining"}}');var s=t(23420),r=t(65404);const c={},a=void 0,d={},i=[{value:"\u2728 Converting Methods to Procs with Symbol#to_proc",id:"-converting-methods-to-procs-with-symbolto_proc",level:2}];function m(e){const o={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.h2,{id:"-converting-methods-to-procs-with-symbolto_proc",children:"\u2728 Converting Methods to Procs with Symbol#to_proc"}),"\n",(0,s.jsxs)(o.p,{children:["Ruby's ",(0,s.jsx)(o.code,{children:"Symbol#to_proc"})," shorthand (",(0,s.jsx)(o.code,{children:"&:method_name"}),") makes mapping and selection more concise. It converts a symbol into a proc that calls the named method on each element. This simplifies common enumerations."]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-ruby",children:'names = ["alice", "bob", "carol"]\n# Using map with a block\nupcased = names.map { |name| name.upcase }\n# Using Symbol#to_proc shorthand\nupcased = names.map(&:upcase)\n\n# Selecting objects by a boolean method\nevens = [1,2,3,4,5].select(&:even?)  #=> [2,4]\n'})})]})}function l(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}}}]);