"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[90767],{43693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"ruby/define_method/advanced/memoization_via_define_method","title":"memoization_via_define_method","description":"\u26a1 Memoization Patterns via define_method","source":"@site/docs/ruby/define_method/advanced/memoization_via_define_method.md","sourceDirName":"ruby/define_method/advanced","slug":"/ruby/define_method/advanced/memoization_via_define_method","permalink":"/keep-being-human-dev/docs/ruby/define_method/advanced/memoization_via_define_method","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/define_method/advanced/memoization_via_define_method.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"dynamic_method_proxy","permalink":"/keep-being-human-dev/docs/ruby/define_method/advanced/dynamic_method_proxy"},"next":{"title":"attribute_getter_setter","permalink":"/keep-being-human-dev/docs/ruby/define_method/beginner/attribute_getter_setter"}}');var o=t(23420),a=t(65404);const d={},r=void 0,c={},m=[{value:"\u26a1 Memoization Patterns via define_method",id:"-memoization-patterns-via-define_method",level:2}];function s(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"-memoization-patterns-via-define_method",children:"\u26a1 Memoization Patterns via define_method"}),"\n",(0,o.jsxs)(n.p,{children:["Leverage ",(0,o.jsx)(n.code,{children:"define_method"})," to DRY memoization logic across multiple expensive computations. By using a loop and ",(0,o.jsx)(n.code,{children:"define_method"}),", you avoid repeating caching boilerplate."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:'class ExpensiveCalculator\n  [:fib, :factorial, :prime_factors].each do |meth|\n    define_method(meth) do |n|\n      cache_var = "@_cache_#{meth}".to_sym\n      @_memo ||= {}\n      @_memo[n] ||= begin\n        puts "Computing #{meth}(#{n})..."\n        send("compute_#{meth}", n)\n      end\n    end\n  end\n\n  private\n\n  def compute_fib(n)\n    return n if n < 2\n    fib(n-1) + fib(n-2)\n  end\n\n  def compute_factorial(n)\n    (1..n).inject(:*) || 1\n  end\n\n  def compute_prime_factors(n)\n    (2..n).select { |i| n % i == 0 }\n  end\nend\n\ncalc = ExpensiveCalculator.new\ncalc.fib(10)       # Computes once, caches for future calls\ncalc.fib(10)       # Instant result from cache\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(s,{...e})}):s(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var i=t(36672);const o={},a=i.createContext(o);function d(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);