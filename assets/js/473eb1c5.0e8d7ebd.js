"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[76503],{53952:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"rails/engines_and_plugins/expert/isolate_namespace_advanced","title":"isolate_namespace_advanced","description":"\u2699\ufe0f Leverage Advanced isolate_namespace Customizations","source":"@site/docs/rails/engines_and_plugins/expert/isolate_namespace_advanced.md","sourceDirName":"rails/engines_and_plugins/expert","slug":"/rails/engines_and_plugins/expert/isolate_namespace_advanced","permalink":"/keep-being-human-dev/docs/rails/engines_and_plugins/expert/isolate_namespace_advanced","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/engines_and_plugins/expert/isolate_namespace_advanced.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_plugin_with_railtie","permalink":"/keep-being-human-dev/docs/rails/engines_and_plugins/expert/custom_plugin_with_railtie"},"next":{"title":"optimize_engine_loading","permalink":"/keep-being-human-dev/docs/rails/engines_and_plugins/expert/optimize_engine_loading"}}');var s=a(23420),t=a(65404);const o={},r=void 0,c={},d=[{value:"\u2699\ufe0f Leverage Advanced <code>isolate_namespace</code> Customizations",id:"\ufe0f-leverage-advanced-isolate_namespace-customizations",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h2,{id:"\ufe0f-leverage-advanced-isolate_namespace-customizations",children:["\u2699\ufe0f Leverage Advanced ",(0,s.jsx)(n.code,{children:"isolate_namespace"})," Customizations"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, ",(0,s.jsx)(n.code,{children:"isolate_namespace"})," sets up a module scope, but you can extend it to customize route names, controller paths, and view prefixes for absolute isolation. This ensures no constant collisions or route helper clashes with the host application. Use initializers in your ",(0,s.jsx)(n.code,{children:"engine.rb"})," to override defaults and inject your own naming convention."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# lib/my_engine/engine.rb\nengine_name = :my_engine\nmodule MyEngine\n  class Engine < ::Rails::Engine\n    isolate_namespace MyEngine\n\n    initializer \"#{engine_name}.route_helpers\" do |app|\n      app.routes.named_routes.helper_names[:main_app_path] = \"#{engine_name}_main_app\"\n    end\n\n    initializer \"#{engine_name}.view_prefixes\" do |_|\n      ActiveSupport.on_load(:action_controller) do\n        prepend_view_path MyEngine::Engine.root.join('app', 'views', 'shared_#{engine_name}')\n      end\n    end\n  end\nend\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var i=a(36672);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);