"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[38057],{1376:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>d,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"ruby/set/advanced/set_thread_safe","title":"set_thread_safe","description":"\ud83d\udd12 Thread\u2010Safe Sets with concurrent\u2011ruby","source":"@site/docs/ruby/set/advanced/set_thread_safe.md","sourceDirName":"ruby/set/advanced","slug":"/ruby/set/advanced/set_thread_safe","permalink":"/keep-being-human-dev/docs/ruby/set/advanced/set_thread_safe","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/set/advanced/set_thread_safe.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"set_key_extractor","permalink":"/keep-being-human-dev/docs/ruby/set/advanced/set_key_extractor"},"next":{"title":"set_transitive_closure","permalink":"/keep-being-human-dev/docs/ruby/set/advanced/set_transitive_closure"}}');var s=n(23420),a=n(65404);const d={},c=void 0,o={},u=[{value:"\ud83d\udd12 Thread\u2010Safe Sets with concurrent\u2011ruby",id:"-threadsafe-sets-with-concurrentruby",level:2}];function i(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"-threadsafe-sets-with-concurrentruby",children:"\ud83d\udd12 Thread\u2010Safe Sets with concurrent\u2011ruby"}),"\n",(0,s.jsxs)(t.p,{children:["Ruby\u2019s ",(0,s.jsx)(t.code,{children:"Set"})," isn\u2019t thread\u2010safe by default. For multi\u2010threaded environments, use ",(0,s.jsx)(t.code,{children:"Concurrent::Set"})," from the ",(0,s.jsx)(t.code,{children:"concurrent\u2011ruby"})," gem. It provides atomic ",(0,s.jsx)(t.code,{children:"add?"}),", ",(0,s.jsx)(t.code,{children:"delete?"}),", and lock\u2010free reads to avoid race conditions."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:"# Add to your Gemfile:\n# gem 'concurrent-ruby'\n\nrequire 'concurrent'\n\n# Create a thread-safe set\nsafe_set = Concurrent::Set.new([1,2,3])\n\nthreads = 10.times.map do |i|\n  Thread.new do\n    100.times do |j|\n      safe_set.add?(i*100 + j)\n    end\n  end\nend\n\nthreads.each(&:join)\n\nputs safe_set.size\n# => 1000  # All adds completed without locks or races\n\n# Atomic delete? returns true if element was present\nputs safe_set.delete?(42) ? 'Removed' : 'Not present'\n"})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>c});var r=n(36672);const s={},a=r.createContext(s);function d(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);