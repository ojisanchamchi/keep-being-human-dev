"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[69990],{18565:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"rails/sessions_and_cookies/advanced/sliding_session_expiration","title":"sliding_session_expiration","description":"\u23f3 Implement Sliding Session Expiration","source":"@site/docs/rails/sessions_and_cookies/advanced/sliding_session_expiration.md","sourceDirName":"rails/sessions_and_cookies/advanced","slug":"/rails/sessions_and_cookies/advanced/sliding_session_expiration","permalink":"/keep-being-human-dev/docs/rails/sessions_and_cookies/advanced/sliding_session_expiration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/sessions_and_cookies/advanced/sliding_session_expiration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"rotate_cookie_encryption_keys","permalink":"/keep-being-human-dev/docs/rails/sessions_and_cookies/advanced/rotate_cookie_encryption_keys"},"next":{"title":"setting_basic_cookies_with_expiry","permalink":"/keep-being-human-dev/docs/rails/sessions_and_cookies/beginner/setting_basic_cookies_with_expiry"}}');var o=s(23420),t=s(65404);const a={},r=void 0,d={},c=[{value:"\u23f3 Implement Sliding Session Expiration",id:"-implement-sliding-session-expiration",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"-implement-sliding-session-expiration",children:"\u23f3 Implement Sliding Session Expiration"}),"\n",(0,o.jsxs)(n.p,{children:["By default, Rails cookie sessions expire after a fixed interval from creation, not from last access. To extend a user\u2019s session on each request, insert a custom middleware that refreshes the cookie\u2019s ",(0,o.jsx)(n.code,{children:"expires"})," attribute on every response. This ensures active users aren\u2019t logged out unexpectedly while still enforcing absolute timeouts."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:'# lib/sliding_session_middleware.rb\nclass SlidingSessionMiddleware\n  def initialize(app, expire_after:)\n    @app = app\n    @expire_after = expire_after\n  end\n\n  def call(env)\n    status, headers, response = @app.call(env)\n    # Only patch the session-cookie\n    if headers["Set-Cookie"]&.include?("_#{Rails.application.class.module_parent_name.underscore}_session")\n      new_expiry = @expire_after.from_now.utc.httpdate\n      headers["Set-Cookie"] = headers.get_all("Set-Cookie").map do |cookie|\n        if cookie.start_with?("_#{Rails.application.class.module_parent_name.underscore}_session")\n          cookie.sub(/expires=[^;]+;/, "expires=#{new_expiry};")\n        else\n          cookie\n        end\n      end\n    end\n    [status, headers, response]\n  end\nend\n\n# config/application.rb\nmodule MyApp\n  class Application < Rails::Application\n    config.load_defaults 7.0\n    config.middleware.insert_before(\n      ActionDispatch::Session::CookieStore,\n      SlidingSessionMiddleware,\n      expire_after: 30.minutes\n    )\n  end\nend\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},65404:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var i=s(36672);const o={},t=i.createContext(o);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);