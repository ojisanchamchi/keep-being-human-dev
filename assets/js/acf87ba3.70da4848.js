"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[30202],{52517:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"rails/middleware/expert/dynamic_request_throttling_middleware","title":"dynamic_request_throttling_middleware","description":"\ud83d\udd27 Implement Dynamic Request Throttling","source":"@site/docs/rails/middleware/expert/dynamic_request_throttling_middleware.md","sourceDirName":"rails/middleware/expert","slug":"/rails/middleware/expert/dynamic_request_throttling_middleware","permalink":"/keep-being-human-dev/docs/rails/middleware/expert/dynamic_request_throttling_middleware","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/middleware/expert/dynamic_request_throttling_middleware.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"conditional_asset_pipeline_forking","permalink":"/keep-being-human-dev/docs/rails/middleware/expert/conditional_asset_pipeline_forking"},"next":{"title":"rotating_security_header_injector","permalink":"/keep-being-human-dev/docs/rails/middleware/expert/rotating_security_header_injector"}}');var r=n(23420),a=n(65404);const o={},s=void 0,d={},l=[{value:"\ud83d\udd27 Implement Dynamic Request Throttling",id:"-implement-dynamic-request-throttling",level:2}];function c(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"-implement-dynamic-request-throttling",children:"\ud83d\udd27 Implement Dynamic Request Throttling"}),"\n",(0,r.jsx)(t.p,{children:"To protect your Rails API from abusive traffic, build a Rack middleware that dynamically throttles per-user or per-endpoint requests using Redis as a sliding\u2010window counter. The middleware increments a Redis counter on each request, sets an expiry window, and returns HTTP\xa0429 once the limit is exceeded, applying exponential backoff on repeated violations. Integrate it early in the stack to fail fast under load spikes."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"class DynamicRequestThrottling\n  def initialize(app, options = {})\n    @app   = app\n    @redis = options.fetch(:redis)\n    @limit = options.fetch(:limit, 100)\n    @window = options.fetch(:window, 60) # seconds\n  end\n\n  def call(env)\n    key = \"throttle:#{extract_identifier(env)}\"\n    count = @redis.get(key).to_i\n    if count >= @limit\n      retry_after = @redis.ttl(key)\n      return [429, {'Content-Type' => 'application/json', 'Retry-After' => retry_after.to_s}, [{error: 'Rate limit exceeded'}.to_json]]\n    end\n\n    @redis.multi do\n      @redis.incr(key)\n      @redis.expire(key, @window)\n    end\n\n    @app.call(env)\n  end\n\n  private\n\n  def extract_identifier(env)\n    # Use IP, API token or user ID from Rack env\n    env['HTTP_X_API_TOKEN'] || env['REMOTE_ADDR']\n  end\nend\n\n# config/application.rb\nRails.application.config.middleware.insert_before 0, DynamicRequestThrottling,\n  redis: Redis.new(url: ENV['REDIS_URL']), limit: 200, window: 60\n"})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var i=n(36672);const r={},a=i.createContext(r);function o(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);