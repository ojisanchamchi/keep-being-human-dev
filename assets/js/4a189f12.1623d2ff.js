"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[22581],{28395:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>i});const s=JSON.parse('{"id":"ruby/hashes/advanced/recursive_deep_merge","title":"recursive_deep_merge","description":"\ud83c\udf00 Recursive Deep Merge","source":"@site/docs/ruby/hashes/advanced/recursive_deep_merge.md","sourceDirName":"ruby/hashes/advanced","slug":"/ruby/hashes/advanced/recursive_deep_merge","permalink":"/keep-being-human-dev/docs/ruby/hashes/advanced/recursive_deep_merge","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/hashes/advanced/recursive_deep_merge.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"nested_transform_keys","permalink":"/keep-being-human-dev/docs/ruby/hashes/advanced/nested_transform_keys"},"next":{"title":"slice_and_except","permalink":"/keep-being-human-dev/docs/ruby/hashes/advanced/slice_and_except"}}');var a=r(23420),t=r(65404);const c={},d=void 0,o={},i=[{value:"\ud83c\udf00 Recursive Deep Merge",id:"-recursive-deep-merge",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"-recursive-deep-merge",children:"\ud83c\udf00 Recursive Deep Merge"}),"\n",(0,a.jsxs)(n.p,{children:["When combining nested Hashes, Ruby\u2019s ",(0,a.jsx)(n.code,{children:"merge"})," only merges top\u2010level keys. For deep structures, implement a recursive deep merge that resolves conflicts via a block. This keeps nested data intact and allows custom conflict resolution."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class ::Hash\n  def deep_merge(other_hash, &conflict_resolver)\n    merger = proc do |key, old_val, new_val|\n      if old_val.is_a?(Hash) && new_val.is_a?(Hash)\n        old_val.merge(new_val, &merger)\n      else\n        conflict_resolver ? conflict_resolver.call(key, old_val, new_val) : new_val\n      end\n    end\n    merge(other_hash, &merger)\n  end\nend\n\nh1 = {a: {x: 1, y: 2}, b: 3}\nh2 = {a: {y: 20, z: 30}, c: 4}\n\n# Use default behavior (new_val)\ndeep = h1.deep_merge(h2)\n#=> {:a=>{:x=>1, :y=>20, :z=>30}, :b=>3, :c=>4}\n\n# Custom conflict: sum values\nsum = h1.deep_merge(h2) { |key, oldv, newv| oldv + newv }\n#=> {:a=>{:x=>1, :y=>22, :z=>30}, :b=>3, :c=>4}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},65404:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>d});var s=r(36672);const a={},t=s.createContext(a);function c(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);