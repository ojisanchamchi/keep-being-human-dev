"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[65297],{65404:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var t=r(36672);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},88232:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"ruby/xml/advanced/high_performance_ox","title":"high_performance_ox","description":"\u26a1\ufe0f High-Performance XML Parsing and Generation with Ox","source":"@site/docs/ruby/xml/advanced/high_performance_ox.md","sourceDirName":"ruby/xml/advanced","slug":"/ruby/xml/advanced/high_performance_ox","permalink":"/keep-being-human-dev/docs/ruby/xml/advanced/high_performance_ox","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/xml/advanced/high_performance_ox.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"parallel_assignment_and_splat","permalink":"/keep-being-human-dev/docs/ruby/variables/middle/parallel_assignment_and_splat"},"next":{"title":"sax_streaming_large_xml","permalink":"/keep-being-human-dev/docs/ruby/xml/advanced/sax_streaming_large_xml"}}');var a=r(23420),i=r(65404);const o={},s=void 0,d={},l=[{value:"\u26a1\ufe0f High-Performance XML Parsing and Generation with Ox",id:"\ufe0f-high-performance-xml-parsing-and-generation-with-ox",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"\ufe0f-high-performance-xml-parsing-and-generation-with-ox",children:"\u26a1\ufe0f High-Performance XML Parsing and Generation with Ox"}),"\n",(0,a.jsxs)(n.p,{children:["For ultra-fast read/write of XML, consider the ",(0,a.jsx)(n.code,{children:"Ox"})," gem, which outperforms Nokogiri in many benchmarks. Ox supports both SAX-like handlers and object mapping, giving you control over speed and memory."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"require 'ox'\n\n# Parsing to a Ruby object tree\nOx.default_options = {mode: :generic, symbolize_keys: true}\nobj = Ox.load_file('large.xml')\nputs obj[:root][:item].first[:name]\n\n# Streaming parse using a handler\ndef handler\n  Ox.sax_parse(Ox::Sax.new { |config|\n    config.start_element do |name, attrs|\n      puts \"Start: #{name}, Attributes: #{attrs}\"\n    end\n    config.text do |text|\n      puts \"Text: #{text.strip}\" unless text.strip.empty?\n    end\n  }, File.open('large.xml'))\nend\n\n# Generating XML quickly\no = {:root => {:item => [{:name => 'foo'}, {:name => 'bar'}]}}\nxml_str = Ox.dump(o, indent: 2)\nputs xml_str\n"})}),"\n",(0,a.jsx)(n.p,{children:"Ox highlights:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"mode: :generic"})," builds a pure Ruby Hash/Array tree."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Ox.load_file"})," is memory-efficient when combined with streaming handlers."]}),"\n",(0,a.jsxs)(n.li,{children:["Fast XML generation with ",(0,a.jsx)(n.code,{children:"Ox.dump"})," and minimal object overhead."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);