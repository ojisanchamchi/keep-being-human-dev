"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[93658],{64260:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"gems/image_processing/expert/parallel_processing_pipeline","title":"parallel_processing_pipeline","description":"\u26a1 Parallel Processing Pipeline","source":"@site/docs/gems/image_processing/expert/parallel_processing_pipeline.md","sourceDirName":"gems/image_processing/expert","slug":"/gems/image_processing/expert/parallel_processing_pipeline","permalink":"/keep-being-human-dev/docs/gems/image_processing/expert/parallel_processing_pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/image_processing/expert/parallel_processing_pipeline.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_mini_magick_operations","permalink":"/keep-being-human-dev/docs/gems/image_processing/expert/custom_mini_magick_operations"},"next":{"title":"background_processing","permalink":"/keep-being-human-dev/docs/gems/image_processing/middle/background_processing"}}');var r=s(23420),o=s(65404);const t={},a=void 0,p={},l=[{value:"\u26a1 Parallel Processing Pipeline",id:"-parallel-processing-pipeline",level:2}];function c(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"-parallel-processing-pipeline",children:"\u26a1 Parallel Processing Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"For CPU\u2011intensive pipelines (e.g., resizing multiple large images), you can fork subprocesses or use concurrent threads to fully utilize multi\u2011core systems. Ensure each subprocess initializes its own ImageMagick context to avoid thread\u2011safety issues."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:'require "concurrent"\nrequire "image_processing/mini_magick"\n\nimages = Dir["uploads/*.jpg"]\n\n# Use Concurrent::Promises for a forking pool\nfutures = images.map do |path|\n  Concurrent::Promises.future_on(Concurrent::FixedThreadPool.new(4)) do\n    ImageProcessing::MiniMagick\n      .source(path)\n      .resize_to_limit(2000, 2000)\n      .strip\n      .quality(85)\n      .call(destination: "processed/#{File.basename(path)}")\n  end\nend\n\n# Wait for all tasks to finish\nConcurrent::Promises.zip(*futures).value!\nputs "All images processed in parallel"\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},65404:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(36672);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);