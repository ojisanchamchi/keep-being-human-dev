"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[41223],{47671:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>d,toc:()=>i});const d=JSON.parse('{"id":"gems/geocoder/advanced/polymorphic_geocoding_multiple_models","title":"polymorphic_geocoding_multiple_models","description":"\u2699\ufe0f Polymorphic Geocoding Across Multiple Models","source":"@site/docs/gems/geocoder/advanced/polymorphic_geocoding_multiple_models.md","sourceDirName":"gems/geocoder/advanced","slug":"/gems/geocoder/advanced/polymorphic_geocoding_multiple_models","permalink":"/keep-being-human-dev/docs/gems/geocoder/advanced/polymorphic_geocoding_multiple_models","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/geocoder/advanced/polymorphic_geocoding_multiple_models.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"geocoder_caching_and_fallback_strategies","permalink":"/keep-being-human-dev/docs/gems/geocoder/advanced/geocoder_caching_and_fallback_strategies"},"next":{"title":"postgis_high_performance_queries","permalink":"/keep-being-human-dev/docs/gems/geocoder/advanced/postgis_high_performance_queries"}}');var o=n(23420),t=n(65404);const r={},a=void 0,c={},i=[{value:"\u2699\ufe0f Polymorphic Geocoding Across Multiple Models",id:"\ufe0f-polymorphic-geocoding-across-multiple-models",level:2}];function l(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h2,{id:"\ufe0f-polymorphic-geocoding-across-multiple-models",children:"\u2699\ufe0f Polymorphic Geocoding Across Multiple Models"}),"\n",(0,o.jsxs)(s.p,{children:["When you have different models sharing address data (e.g., User and Event), a polymorphic ",(0,o.jsx)(s.code,{children:"Address"})," model prevents duplication. Set up ",(0,o.jsx)(s.code,{children:"Address"})," to geocode any addressable model:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ruby",children:"class Address < ApplicationRecord\n  belongs_to :addressable, polymorphic: true\n\n  geocoded_by :full_address\n  after_validation :geocode, if: :will_save_change_to_full_address?\nend\n\nclass CreateAddresses < ActiveRecord::Migration[6.1]\n  def change\n    create_table :addresses do |t|\n      t.string :street\n      t.string :city\n      t.string :state\n      t.string :zip\n      t.string :addressable_type\n      t.bigint :addressable_id\n      t.float :latitude\n      t.float :longitude\n      t.timestamps\n    end\n\n    add_index :addresses, [:addressable_type, :addressable_id]\n  end\nend\n"})}),"\n",(0,o.jsx)(s.p,{children:"Then in your models:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ruby",children:"class User < ApplicationRecord\n  has_one :address, as: :addressable, dependent: :destroy\n  accepts_nested_attributes_for :address\nend\n\nclass Event < ApplicationRecord\n  has_one :address, as: :addressable, dependent: :destroy\n  accepts_nested_attributes_for :address\nend\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Now both ",(0,o.jsx)(s.code,{children:"User"})," and ",(0,o.jsx)(s.code,{children:"Event"})," will geocode their addresses automatically, and you can run combined queries on the ",(0,o.jsx)(s.code,{children:"addresses"})," table for location\u2011based features."]})]})}function p(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},65404:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var d=n(36672);const o={},t=d.createContext(o);function r(e){const s=d.useContext(t);return d.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),d.createElement(t.Provider,{value:s},e.children)}}}]);