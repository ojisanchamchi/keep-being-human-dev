"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[78e3],{10397:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>p,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"gems/bcrypt/expert/bcrypt_async_hashing","title":"bcrypt_async_hashing","description":"\ud83d\ude80 Offload Bcrypt Hashing to Background Jobs","source":"@site/docs/gems/bcrypt/expert/bcrypt_async_hashing.md","sourceDirName":"gems/bcrypt/expert","slug":"/gems/bcrypt/expert/bcrypt_async_hashing","permalink":"/keep-being-human-dev/docs/gems/bcrypt/expert/bcrypt_async_hashing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/bcrypt/expert/bcrypt_async_hashing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"bcrypt_model_setup","permalink":"/keep-being-human-dev/docs/gems/bcrypt/beginner/bcrypt_model_setup"},"next":{"title":"bcrypt_legacy_migration","permalink":"/keep-being-human-dev/docs/gems/bcrypt/expert/bcrypt_legacy_migration"}}');var t=r(23420),a=r(65404);const o={},p=void 0,c={},d=[{value:"\ud83d\ude80 Offload Bcrypt Hashing to Background Jobs",id:"-offload-bcrypt-hashing-to-background-jobs",level:2}];function i(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"-offload-bcrypt-hashing-to-background-jobs",children:"\ud83d\ude80 Offload Bcrypt Hashing to Background Jobs"}),"\n",(0,t.jsx)(s.p,{children:"Offload expensive bcrypt computations to background workers to keep web threads responsive. Temporarily store the raw password, enqueue a job after commit, then update the digest asynchronously with pepper and proper cost."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ruby",children:"# app/models/user.rb\nclass User < ApplicationRecord\n  attr_accessor :raw_password\n\n  after_commit :enqueue_password_hash, if: -> { raw_password.present? }\n\n  # Capture raw password and defer hashing\n  def password=(pwd)\n    self.raw_password = pwd\n  end\n\n  private\n\n  def enqueue_password_hash\n    PasswordHashJob.perform_later(id, raw_password)\n  end\nend\n"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ruby",children:"# app/jobs/password_hash_job.rb\nclass PasswordHashJob < ApplicationJob\n  queue_as :default\n\n  def perform(user_id, raw_password)\n    pepper = ENV.fetch('PASSWORD_PEPPER')\n    cost   = ENV.fetch('BCRYPT_COST', 12).to_i\n    digest = BCrypt::Password.create(\"#{raw_password}#{pepper}\", cost: cost)\n    User.where(id: user_id).update_all(password_digest: digest)\n  end\nend\n"})})]})}function u(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}},65404:(e,s,r)=>{r.d(s,{R:()=>o,x:()=>p});var n=r(36672);const t={},a=n.createContext(t);function o(e){const s=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function p(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);