"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[73757],{32816:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>m});const a=JSON.parse('{"id":"gems/ruby-openai/expert/dynamic_function_call_management","title":"dynamic_function_call_management","description":"\u2699\ufe0f Master Dynamic Function Calling with Complex Schemas","source":"@site/docs/gems/ruby-openai/expert/dynamic_function_call_management.md","sourceDirName":"gems/ruby-openai/expert","slug":"/gems/ruby-openai/expert/dynamic_function_call_management","permalink":"/keep-being-human-dev/docs/gems/ruby-openai/expert/dynamic_function_call_management","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/ruby-openai/expert/dynamic_function_call_management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"advanced_streaming_with_backpressure","permalink":"/keep-being-human-dev/docs/gems/ruby-openai/expert/advanced_streaming_with_backpressure"},"next":{"title":"high_throughput_rate_limited_requests","permalink":"/keep-being-human-dev/docs/gems/ruby-openai/expert/high_throughput_rate_limited_requests"}}');var s=t(23420),i=t(65404);const r={},c=void 0,o={},m=[{value:"\u2699\ufe0f Master Dynamic Function Calling with Complex Schemas",id:"\ufe0f-master-dynamic-function-calling-with-complex-schemas",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"\ufe0f-master-dynamic-function-calling-with-complex-schemas",children:"\u2699\ufe0f Master Dynamic Function Calling with Complex Schemas"}),"\n",(0,s.jsx)(n.p,{children:"For expert-level function calling, dynamically generate and handle multiple functions with nested JSON schemas. Leverage Ruby\u2019s metaprogramming to register handlers and coerce incoming arguments into rich domain objects. This approach keeps your codebase DRY and easily testable when managing dozens of functions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"require 'openai'\n\nclass FunctionRegistry\n  def initialize(client)\n    @client = client\n    @functions = {}\n  end\n\n  def register(name, schema, &block)\n    @functions[name] = { schema: schema, handler: block }\n  end\n\n  def call(user_prompt)\n    response = @client.chat.completions(\n      model: 'gpt-4o',\n      messages: [{ role: 'user', content: user_prompt }],\n      functions: @functions.transform_values { |f| f[:schema] },\n      function_call: { name: 'auto' }\n    )\n    data = JSON.parse(response.dig('choices',0,'message','function_call','arguments'))\n    func = response.dig('choices',0,'message','function_call','name')\n    @functions[func][:handler].call(**data.symbolize_keys)\n  end\nend\n\nclient = OpenAI::Client.new\nregistry = FunctionRegistry.new(client)\n\nregistry.register('create_user', {\n  name: 'create_user',\n  description: 'Creates a new user in the system',\n  parameters: { type: 'object', properties: { username: { type: 'string' }, age: { type: 'integer' } }, required: ['username'] }\n}) do |username:, age: nil|\n  User.create!(username: username, age: age)\nend\n\n# Invoke with automatic dispatch\nregistry.call(\"Please register a user named \\\"alice\\\" aged 30.\")\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(36672);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);