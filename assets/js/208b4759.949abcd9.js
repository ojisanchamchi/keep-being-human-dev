"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[7858],{58930:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"nosql/redis/advanced/redis_streams","title":"redis_streams","description":"\ud83c\udf0a Leverage Redis Streams for Event Sourcing","source":"@site/docs/nosql/redis/advanced/redis_streams.md","sourceDirName":"nosql/redis/advanced","slug":"/nosql/redis/advanced/redis_streams","permalink":"/keep-being-human-dev/docs/nosql/redis/advanced/redis_streams","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nosql/redis/advanced/redis_streams.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"redis_pipelining","permalink":"/keep-being-human-dev/docs/nosql/redis/advanced/redis_pipelining"},"next":{"title":"redis_basic_key_value","permalink":"/keep-being-human-dev/docs/nosql/redis/beginner/redis_basic_key_value"}}');var t=n(23420),i=n(65404);const a={},d=void 0,o={},c=[{value:"\ud83c\udf0a Leverage Redis Streams for Event Sourcing",id:"-leverage-redis-streams-for-event-sourcing",level:2}];function u(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"-leverage-redis-streams-for-event-sourcing",children:"\ud83c\udf0a Leverage Redis Streams for Event Sourcing"}),"\n",(0,t.jsxs)(s.p,{children:["Redis Streams provide an append-only log data structure perfect for building event-driven architectures or message queues. Using consumer groups, you can distribute workload among multiple workers and guarantee at-least-once delivery. Streams also support trimming policies (",(0,t.jsx)(s.code,{children:"XTRIM"}),") to cap memory usage while retaining recent history."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ruby",children:"require 'redis'\nredis = Redis.new\n\nevent = { user: 'alice', action: 'login', time: Time.now.to_i }\n# Append an event to the stream\nid = redis.xadd('user:events', '*', event)\nputs \"Event appended with ID: #{id}\"\n\n# Create a consumer group (idempotent)\nbegin\n  redis.xgroup('CREATE', 'user:events', 'analytics', '$', mkstream: true)\nrescue Redis::CommandError => e\n  raise unless e.message.include?('BUSYGROUP')\nend\n\n# Read from the group as a consumer\nmessages = redis.xreadgroup('GROUP', 'analytics', 'worker-1', 'BLOCK', 2000, 'COUNT', 10, 'STREAMS', 'user:events', '>' )\nmessages.each do |stream, entries|\n  entries.each do |msg_id, fields|\n    puts \"Processing #{msg_id}: #{fields}\"  \n    # Acknowledge after processing\n    redis.xack('user:events', 'analytics', msg_id)\n  end\nend\n"})})]})}function l(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},65404:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>d});var r=n(36672);const t={},i=r.createContext(t);function a(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);