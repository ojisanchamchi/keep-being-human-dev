"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[38918],{5525:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"rails/active_record_validations/expert/db_constraints_parallel","title":"db_constraints_parallel","description":"\ud83d\udee1\ufe0f Enforcing DB Constraints in Parallel","source":"@site/docs/rails/active_record_validations/expert/db_constraints_parallel.md","sourceDirName":"rails/active_record_validations/expert","slug":"/rails/active_record_validations/expert/db_constraints_parallel","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/db_constraints_parallel","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_validations/expert/db_constraints_parallel.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_validator_classes","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/custom_validator_classes"},"next":{"title":"defer_validations_before_validation","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/defer_validations_before_validation"}}');var t=a(23420),i=a(65404);const s={},o=void 0,d={},l=[{value:"\ud83d\udee1\ufe0f Enforcing DB Constraints in Parallel",id:"\ufe0f-enforcing-db-constraints-in-parallel",level:2}];function c(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"\ufe0f-enforcing-db-constraints-in-parallel",children:"\ud83d\udee1\ufe0f Enforcing DB Constraints in Parallel"}),"\n",(0,t.jsx)(n.p,{children:"Complement Rails validations with database constraints to avoid race conditions and ensure data integrity at scale. Use migrations to add unique or check constraints, then rescue and normalize database errors into model errors."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"# db/migrate/20240101000000_add_unique_index_to_users_email.rb\nclass AddUniqueIndexToUsersEmail < ActiveRecord::Migration[7.0]\n  def change\n    add_index :users, :email, unique: true, name: 'index_users_on_email_unique'\n  end\nend\n\n# app/models/user.rb\nclass User < ApplicationRecord\n  validates :email, presence: true, uniqueness: true\n\n  rescue_from ActiveRecord::RecordNotUnique do |exception|\n    errors.add(:email, :taken, message: 'has already been registered')\n  end\nend\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var r=a(36672);const t={},i=r.createContext(t);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);