"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[87999],{41633:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ruby/reflection/expert/granular_tracepoint_events","title":"granular_tracepoint_events","description":"\ud83d\udd75\ufe0f TracePoint for Granular Runtime Event Tracing","source":"@site/docs/ruby/reflection/expert/granular_tracepoint_events.md","sourceDirName":"ruby/reflection/expert","slug":"/ruby/reflection/expert/granular_tracepoint_events","permalink":"/keep-being-human-dev/docs/ruby/reflection/expert/granular_tracepoint_events","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/reflection/expert/granular_tracepoint_events.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"dynamic_basicobject_proxy","permalink":"/keep-being-human-dev/docs/ruby/reflection/expert/dynamic_basicobject_proxy"},"next":{"title":"singleton_class_hierarchy","permalink":"/keep-being-human-dev/docs/ruby/reflection/expert/singleton_class_hierarchy"}}');var a=t(23420),i=t(65404);const c={},o=void 0,s={},l=[{value:"\ud83d\udd75\ufe0f TracePoint for Granular Runtime Event Tracing",id:"\ufe0f-tracepoint-for-granular-runtime-event-tracing",level:2}];function u(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"\ufe0f-tracepoint-for-granular-runtime-event-tracing",children:"\ud83d\udd75\ufe0f TracePoint for Granular Runtime Event Tracing"}),"\n",(0,a.jsx)(n.p,{children:"TracePoint lets you hook into Ruby\u2019s runtime and inspect or alter behavior at the bytecode level. You can track method calls, class definitions, and even garbage collection events, all with minimal overhead."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Trace all method calls within a specific class\ntrace = TracePoint.new(:call, :return) do |tp|\n  if tp.defined_class == MyClass && tp.event == :call\n    puts "Calling #{tp.method_id} with args=#{tp.parameters.inspect}"\n  end\nend\ntrace.enable\nMyClass.new.foo(1, 2)\ntrace.disable\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Combine multiple event types (e.g., ",":class",", ",":line",") and inspect ",(0,a.jsx)(n.code,{children:"tp.binding"})," to dynamically inject logic or analyze local variables at precise execution points."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var r=t(36672);const a={},i=r.createContext(a);function c(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);