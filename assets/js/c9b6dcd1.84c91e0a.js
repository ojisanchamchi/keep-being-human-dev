"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[27261],{4186:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>l,contentTitle:()=>n,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"rails/active_record_validations/expert/custom_validator_classes","title":"custom_validator_classes","description":"\u2699\ufe0f Using Custom Validator Classes","source":"@site/docs/rails/active_record_validations/expert/custom_validator_classes.md","sourceDirName":"rails/active_record_validations/expert","slug":"/rails/active_record_validations/expert/custom_validator_classes","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/custom_validator_classes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_validations/expert/custom_validator_classes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"contextual_validations","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/contextual_validations"},"next":{"title":"db_constraints_parallel","permalink":"/keep-being-human-dev/docs/rails/active_record_validations/expert/db_constraints_parallel"}}');var r=s(23420),o=s(65404);const i={},n=void 0,l={},c=[{value:"\u2699\ufe0f Using Custom Validator Classes",id:"\ufe0f-using-custom-validator-classes",level:2}];function d(e){const a={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"\ufe0f-using-custom-validator-classes",children:"\u2699\ufe0f Using Custom Validator Classes"}),"\n",(0,r.jsx)(a.p,{children:"Centralize complex validation logic by creating custom validator classes. This approach keeps your models clean, allows reusing logic across different models, and lets you leverage I18n for error messages. You can also pass options to your validator to tweak behavior per model."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-ruby",children:"# app/validators/email_format_validator.rb\nclass EmailFormatValidator < ActiveModel::EachValidator\n  REGEX = /\\A[^@\\s]+@[^@\\s]+\\z/\n\n  def validate_each(record, attribute, value)\n    return if value =~ REGEX\n    record.errors.add(attribute, :invalid_email, message: options[:message] || \"is not a valid email\")\n  end\nend\n\n# app/models/user.rb\nclass User < ApplicationRecord\n  validates :email, presence: true, email_format: { message: 'must be a corporate email' }\nend\n"})})]})}function u(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},65404:(e,a,s)=>{s.d(a,{R:()=>i,x:()=>n});var t=s(36672);const r={},o=t.createContext(r);function i(e){const a=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function n(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:a},e.children)}}}]);