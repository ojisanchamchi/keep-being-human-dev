"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[17561],{65404:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>r});var o=n(36672);const t={},c=o.createContext(t);function i(e){const s=o.useContext(c);return o.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(c.Provider,{value:s},e.children)}},67536:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"ruby/sockets/advanced/unix_socket_fd_passing","title":"unix_socket_fd_passing","description":"\ud83d\udee0\ufe0f Passing File Descriptors over UNIX Domain Sockets","source":"@site/docs/ruby/sockets/advanced/unix_socket_fd_passing.md","sourceDirName":"ruby/sockets/advanced","slug":"/ruby/sockets/advanced/unix_socket_fd_passing","permalink":"/keep-being-human-dev/docs/ruby/sockets/advanced/unix_socket_fd_passing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/sockets/advanced/unix_socket_fd_passing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ssl_tls_with_openssl","permalink":"/keep-being-human-dev/docs/ruby/sockets/advanced/ssl_tls_with_openssl"},"next":{"title":"tcp_client_basics","permalink":"/keep-being-human-dev/docs/ruby/sockets/beginner/tcp_client_basics"}}');var t=n(23420),c=n(65404);const i={},r=void 0,a={},d=[{value:"\ud83d\udee0\ufe0f Passing File Descriptors over UNIX Domain Sockets",id:"\ufe0f-passing-file-descriptors-over-unix-domain-sockets",level:2}];function p(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"\ufe0f-passing-file-descriptors-over-unix-domain-sockets",children:"\ud83d\udee0\ufe0f Passing File Descriptors over UNIX Domain Sockets"}),"\n",(0,t.jsxs)(s.p,{children:["UNIX domain sockets support sending open file descriptors between processes via ",(0,t.jsx)(s.code,{children:"send_io"})," and ",(0,t.jsx)(s.code,{children:"recv_io"}),". This lets you centralize resource management (e.g., listening sockets or temp files) in one process and share them securely with workers."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ruby",children:"require 'socket'\n\n# Parent process: create a UNIX socket and open a file\nserver = UNIXServer.new('/tmp/ipc.sock')\nfile_to_share = File.open('/var/log/myapp.log', 'a')\n\n# Fork a child to receive the FD\npid = fork do\n  sock = server.accept\n  received_file = sock.recv_io\n  received_file.puts \"Child wrote at #{Time.now}\\n\"\n  received_file.close\n  sock.close\nend\n\n# Parent sends the file descriptor\nsock = UNIXSocket.new('/tmp/ipc.sock')\nsock.send_io(file_to_share)\nsock.close\nfile_to_share.close\nProcess.wait(pid)\n"})}),"\n",(0,t.jsx)(s.p,{children:"This technique avoids reopening resources and can pass sockets, pipes, or files securely across privilege boundaries."})]})}function l(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);