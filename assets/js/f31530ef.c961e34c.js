"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[88852],{65404:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>a});var s=n(36672);const t={},o=s.createContext(t);function i(e){const r=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:r},e.children)}},80882:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"nosql/redis/expert/redis_streams_event_sourcing","title":"redis_streams_event_sourcing","description":"\ud83d\udcc8 Implement Event Sourcing with Redis Streams","source":"@site/docs/nosql/redis/expert/redis_streams_event_sourcing.md","sourceDirName":"nosql/redis/expert","slug":"/nosql/redis/expert/redis_streams_event_sourcing","permalink":"/keep-being-human-dev/docs/nosql/redis/expert/redis_streams_event_sourcing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nosql/redis/expert/redis_streams_event_sourcing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"redis_lua_atomic_operations","permalink":"/keep-being-human-dev/docs/nosql/redis/expert/redis_lua_atomic_operations"},"next":{"title":"redis_api_rate_limiter","permalink":"/keep-being-human-dev/docs/nosql/redis/middle/redis_api_rate_limiter"}}');var t=n(23420),o=n(65404);const i={},a=void 0,d={},c=[{value:"\ud83d\udcc8 Implement Event Sourcing with Redis Streams",id:"-implement-event-sourcing-with-redis-streams",level:2}];function u(e){const r={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"-implement-event-sourcing-with-redis-streams",children:"\ud83d\udcc8 Implement Event Sourcing with Redis Streams"}),"\n",(0,t.jsxs)(r.p,{children:["Redis Streams provide an append\u2011only log ideal for event sourcing, offering instant fan\u2011out and consumer groups for guaranteed, scalable processing. By modeling state changes as discrete events, you can rebuild application state at any point and handle back\u2011pressure gracefully. Use ",(0,t.jsx)(r.code,{children:"XADD"})," to log events, ",(0,t.jsx)(r.code,{children:"XREADGROUP"})," for consumers, and ",(0,t.jsx)(r.code,{children:"XACK"})," to mark successes."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ruby",children:"# publisher.rb\nevent = {id: SecureRandom.uuid, type: 'OrderCreated', payload: {order_id: 42, total: 99.99}}\n$redis.xadd('orders:stream', '*', event)\n\n# consumer.rb\ngroup = 'order_processors'\nstream = 'orders:stream'\nbegin\n  $redis.xgroup('CREATE', stream, group, '$', mkstream: true)\nrescue Redis::CommandError; end\n\nloop do\n  entries = $redis.xreadgroup(group, 'consumer-1', {stream => '>'}, count: 10, block: 5_000)\n  next unless entries\n\n  entries.each do |_, msgs|\n    msgs.each do |id, data|\n      process_order(data)\n      $redis.xack(stream, group, id)\n    end\n  end\nend\n"})})]})}function l(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}}}]);