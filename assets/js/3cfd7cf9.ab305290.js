"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[93350],{18007:(e,o,r)=>{r.r(o),r.d(o,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"rails/active_record_querying/expert/eager_loading_nested_polymorphic","title":"eager_loading_nested_polymorphic","description":"\ud83d\udd0d Eager-Load Nested Polymorphic Associations","source":"@site/docs/rails/active_record_querying/expert/eager_loading_nested_polymorphic.md","sourceDirName":"rails/active_record_querying/expert","slug":"/rails/active_record_querying/expert/eager_loading_nested_polymorphic","permalink":"/keep-being-human-dev/docs/rails/active_record_querying/expert/eager_loading_nested_polymorphic","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_record_querying/expert/eager_loading_nested_polymorphic.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ctes_with_active_record","permalink":"/keep-being-human-dev/docs/rails/active_record_querying/expert/ctes_with_active_record"},"next":{"title":"explain_analyze_inspection","permalink":"/keep-being-human-dev/docs/rails/active_record_querying/expert/explain_analyze_inspection"}}');var t=r(23420),i=r(65404);const s={},c=void 0,a={},d=[{value:"\ud83d\udd0d Eager-Load Nested Polymorphic Associations",id:"-eager-load-nested-polymorphic-associations",level:2}];function l(e){const o={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.h2,{id:"-eager-load-nested-polymorphic-associations",children:"\ud83d\udd0d Eager-Load Nested Polymorphic Associations"}),"\n",(0,t.jsxs)(o.p,{children:["ActiveRecord\u2019s ",(0,t.jsx)(o.code,{children:"includes"})," can be combined with nested polymorphic associations to prevent N+1 queries even in complex models. You can specify a lambda to filter which polymorphic type to eager-load, reducing memory overhead and improving performance. This is crucial for dashboards or reports that traverse multiple layers of polymorphic relationships."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ruby",children:"# Assuming Comment belongs_to :commentable, polymorphic: true\nPost.includes(comments: :commentable)\n    .where(comments: { commentable_type: 'Image' })\n    .references(:comments)\n"})}),"\n",(0,t.jsxs)(o.p,{children:["You can replace ",(0,t.jsx)(o.code,{children:".references(:comments)"})," with a scope to only fetch necessary columns or add conditions on the polymorphic target."]})]})}function p(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},65404:(e,o,r)=>{r.d(o,{R:()=>s,x:()=>c});var n=r(36672);const t={},i=n.createContext(t);function s(e){const o=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(i.Provider,{value:o},e.children)}}}]);