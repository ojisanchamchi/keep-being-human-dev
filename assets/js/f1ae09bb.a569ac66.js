"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[99791],{35016:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"rails/authentication_and_authorization/advanced/jwt_refresh_token_rotation","title":"jwt_refresh_token_rotation","description":"\ud83d\udd11 Implement JWT Refresh Token Rotation","source":"@site/docs/rails/authentication_and_authorization/advanced/jwt_refresh_token_rotation.md","sourceDirName":"rails/authentication_and_authorization/advanced","slug":"/rails/authentication_and_authorization/advanced/jwt_refresh_token_rotation","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/advanced/jwt_refresh_token_rotation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/authentication_and_authorization/advanced/jwt_refresh_token_rotation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_devise_warden_strategy","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/advanced/custom_devise_warden_strategy"},"next":{"title":"multi_tenant_policy_scoping","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/advanced/multi_tenant_policy_scoping"}}');var o=t(23420),r=t(65404);const s={},i=void 0,c={},d=[{value:"\ud83d\udd11 Implement JWT Refresh Token Rotation",id:"-implement-jwt-refresh-token-rotation",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"-implement-jwt-refresh-token-rotation",children:"\ud83d\udd11 Implement JWT Refresh Token Rotation"}),"\n",(0,o.jsx)(n.p,{children:"Stateless JWT API tokens risk stolen credentials; rotating refresh tokens after each use improves security by invalidating old tokens immediately. Store a hashed version of the refresh token in the database and issue short\u2011lived access tokens along with long\u2011lived refresh tokens."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:"# app/models/user.rb\nclass User < ApplicationRecord\n  has_secure_token :refresh_token\nend\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:"# app/controllers/api/v1/auth_controller.rb\nclass Api::V1::AuthController < ApplicationController\n  def refresh\n    old_token = params[:refresh_token]\n    user = User.find_by(refresh_token: Digest::SHA256.hexdigest(old_token))\n    return head :unauthorized unless user\n\n    # Rotate token\n    new_token = user.regenerate_refresh_token\n    access_token = JWT.encode({ sub: user.id, exp: 15.minutes.from_now.to_i }, Rails.application.secret_key_base)\n\n    render json: { access_token: access_token, refresh_token: new_token }\n  end\nend\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each time the client calls ",(0,o.jsx)(n.code,{children:"/refresh"}),", the server generates and stores a new ",(0,o.jsx)(n.code,{children:"refresh_token"}),", invalidating the previous one."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(36672);const o={},r=a.createContext(o);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);