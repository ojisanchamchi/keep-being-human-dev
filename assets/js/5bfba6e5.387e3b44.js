"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[96217],{33383:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"ruby/numbers/expert/expert_ffi_math_library","title":"expert_ffi_math_library","description":"\ud83d\udee0\ufe0f Integrating Ruby with GMP via Fiddle for Mega-scale Integers","source":"@site/docs/ruby/numbers/expert/expert_ffi_math_library.md","sourceDirName":"ruby/numbers/expert","slug":"/ruby/numbers/expert/expert_ffi_math_library","permalink":"/keep-being-human-dev/docs/ruby/numbers/expert/expert_ffi_math_library","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/numbers/expert/expert_ffi_math_library.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"expert_bitwise_binary","permalink":"/keep-being-human-dev/docs/ruby/numbers/expert/expert_bitwise_binary"},"next":{"title":"expert_prime_enumeration","permalink":"/keep-being-human-dev/docs/ruby/numbers/expert/expert_prime_enumeration"}}');var i=r(23420),s=r(65404);const a={},o=void 0,d={},l=[{value:"\ud83d\udee0\ufe0f Integrating Ruby with GMP via Fiddle for Mega-scale Integers",id:"\ufe0f-integrating-ruby-with-gmp-via-fiddle-for-mega-scale-integers",level:2}];function u(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"\ufe0f-integrating-ruby-with-gmp-via-fiddle-for-mega-scale-integers",children:"\ud83d\udee0\ufe0f Integrating Ruby with GMP via Fiddle for Mega-scale Integers"}),"\n",(0,i.jsxs)(t.p,{children:["When you need unrestricted integer sizes and blazing performance, bind Ruby to GMP (GNU MP) using ",(0,i.jsx)(t.code,{children:"Fiddle"}),". You\u2019ll get C\u2010level arithmetic speeds for huge numbers, ideal for cryptography or scientific computing."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"require 'fiddle'\nrequire 'fiddle/import'\n\nmodule GMP\n  extend Fiddle::Importer\n  dlload 'libgmp.so'  # ensure libgmp is installed\n  extern 'void mpz_init(void*)'\n  extern 'void mpz_set_str(void*, char*, int)'\n  extern 'char* mpz_get_str(char*, int, void*)'\nend\n\n# Allocate and initialize two big integers\na_ptr = Fiddle::Pointer.malloc(Fiddle::SIZEOF_VOIDP)\nb_ptr = Fiddle::Pointer.malloc(Fiddle::SIZEOF_VOIDP)\n\nGMP.mpz_init(a_ptr)\nGMP.mpz_init(b_ptr)\n# Set from string (base 10)\nGMP.mpz_set_str(a_ptr, '12345678901234567890', 10)\nGMP.mpz_set_str(b_ptr, '98765432109876543210', 10)\n\n# Use GMP functions (e.g., mpz_add) similarly\n# Retrieve as string\nresult_str = GMP.mpz_get_str(nil, 10, a_ptr)\nputs \"Result: #{result_str}\"\n"})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},65404:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>o});var n=r(36672);const i={},s=n.createContext(i);function a(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);