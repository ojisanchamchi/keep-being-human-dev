"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[94038],{43582:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"gems/solid_queue/expert/atomic_job_deduplication","title":"atomic_job_deduplication","description":"\ud83d\udd12 Atomic Job Deduplication with Redis Lua","source":"@site/docs/gems/solid_queue/expert/atomic_job_deduplication.md","sourceDirName":"gems/solid_queue/expert","slug":"/gems/solid_queue/expert/atomic_job_deduplication","permalink":"/keep-being-human-dev/docs/gems/solid_queue/expert/atomic_job_deduplication","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/solid_queue/expert/atomic_job_deduplication.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"schedule_job_future","permalink":"/keep-being-human-dev/docs/gems/solid_queue/beginner/schedule_job_future"},"next":{"title":"dynamic_queue_sharding","permalink":"/keep-being-human-dev/docs/gems/solid_queue/expert/dynamic_queue_sharding"}}');var u=i(23420),o=i(65404);const s={},d=void 0,c={},a=[{value:"\ud83d\udd12 Atomic Job Deduplication with Redis Lua",id:"-atomic-job-deduplication-with-redis-lua",level:2}];function r(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,u.jsxs)(u.Fragment,{children:[(0,u.jsx)(n.h2,{id:"-atomic-job-deduplication-with-redis-lua",children:"\ud83d\udd12 Atomic Job Deduplication with Redis Lua"}),"\n",(0,u.jsx)(n.p,{children:"To prevent duplicate jobs under high concurrency, use Redis Lua scripts for atomic checks and inserts. This ensures that checking for existence and pushing to the queue happens as one indivisible operation."}),"\n",(0,u.jsx)(n.pre,{children:(0,u.jsx)(n.code,{className:"language-ruby",children:"# config/initializers/solid_queue.lua_deduplication.rb\nDEDUP_SCRIPT = <<~LUA\n  if redis.call('SISMEMBER', KEYS[1], ARGV[1]) == 1 then\n    return 0\n  else\n    redis.call('SADD', KEYS[1], ARGV[1])\n    redis.call('LPUSH', KEYS[2], ARGV[1])\n    return 1\n  end\nLUA\n\nclass SolidQueue::Client\n  def enqueue_unique(job_id, payload, queue:)\n    dedup_key = \"dedup:#{queue}\"\n    queue_key = \"queue:#{queue}\"\n    result = redis.eval(DEDUP_SCRIPT, keys: [dedup_key, queue_key], argv: [job_id])\n    result == 1\n  end\nend\n\n# Usage\nclient = SolidQueue::Client.new\nclient.enqueue_unique(\"job-123\", { action: 'process' }, queue: 'critical')\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,u.jsx)(n,{...e,children:(0,u.jsx)(r,{...e})}):r(e)}},65404:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>d});var t=i(36672);const u={},o=t.createContext(u);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(u):e.components||u:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);