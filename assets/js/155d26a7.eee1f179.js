"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[67174],{29851:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"rails/active_support/advanced/notifications_instrumentation","title":"notifications_instrumentation","description":"\u26a1 Instrument Custom Events with ActiveSupport::Notifications","source":"@site/docs/rails/active_support/advanced/notifications_instrumentation.md","sourceDirName":"rails/active_support/advanced","slug":"/rails/active_support/advanced/notifications_instrumentation","permalink":"/keep-being-human-dev/docs/rails/active_support/advanced/notifications_instrumentation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/active_support/advanced/notifications_instrumentation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"nested_hash_transformations","permalink":"/keep-being-human-dev/docs/rails/active_support/advanced/nested_hash_transformations"},"next":{"title":"per_thread_registry","permalink":"/keep-being-human-dev/docs/rails/active_support/advanced/per_thread_registry"}}');var o=n(23420),s=n(65404);const r={},a=void 0,c={},u=[{value:"\u26a1 Instrument Custom Events with ActiveSupport::Notifications",id:"-instrument-custom-events-with-activesupportnotifications",level:2}];function d(t){const e={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"-instrument-custom-events-with-activesupportnotifications",children:"\u26a1 Instrument Custom Events with ActiveSupport::Notifications"}),"\n",(0,o.jsx)(e.p,{children:"ActiveSupport::Notifications lets you profile, log, or react to any custom event in your Rails application. You can instrument code blocks with arbitrary names and payloads, then subscribe to specific patterns using regex or exact names. This is great for monitoring performance hotspots without tightly coupling to your business logic."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ruby",children:'# Instrument a custom event with a payload\nActiveSupport::Notifications.instrument(\'order.process\', order_id: order.id) do\n  order.process!\nend\n\n# Subscribe to all "order.*" events and log durations\nActiveSupport::Notifications.subscribe(/order\\./) do |name, start, finish, id, payload|\n  duration = (finish - start) * 1000\n  Rails.logger.info "#{name} for order ##{payload[:order_id]} took #{duration.round(2)}ms"\nend\n'})})]})}function p(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(d,{...t})}):d(t)}},65404:(t,e,n)=>{n.d(e,{R:()=>r,x:()=>a});var i=n(36672);const o={},s=i.createContext(o);function r(t){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:r(t.components),i.createElement(s.Provider,{value:e},t.children)}}}]);