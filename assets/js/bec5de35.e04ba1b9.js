"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[86857],{40836:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"ruby/sockets/middle/tcp_server_basic","title":"tcp_server_basic","description":"\ud83d\udee0 Simple TCP Server with TCPServer","source":"@site/docs/ruby/sockets/middle/tcp_server_basic.md","sourceDirName":"ruby/sockets/middle","slug":"/ruby/sockets/middle/tcp_server_basic","permalink":"/keep-being-human-dev/docs/ruby/sockets/middle/tcp_server_basic","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/sockets/middle/tcp_server_basic.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"tcp_client_basic","permalink":"/keep-being-human-dev/docs/ruby/sockets/middle/tcp_client_basic"},"next":{"title":"binary_encoding_manipulation","permalink":"/keep-being-human-dev/docs/ruby/strings/advanced/binary_encoding_manipulation"}}');var s=n(23420),i=n(65404);const c={},o=void 0,a={},d=[{value:"\ud83d\udee0 Simple TCP Server with TCPServer",id:"-simple-tcp-server-with-tcpserver",level:2}];function l(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"-simple-tcp-server-with-tcpserver",children:"\ud83d\udee0 Simple TCP Server with TCPServer"}),"\n",(0,s.jsx)(t.p,{children:"Learn how to set up a lightweight TCP server that listens for incoming connections and echoes received data back to the client. This pattern is a foundation for building chat servers, proxies, or custom protocols."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'require \'socket\'\n\nserver = TCPServer.new(\'0.0.0.0\', 3000)\nputs "Server listening on port 3000"\n\nloop do\n  client = server.accept       # Wait for a client to connect\n  data = client.gets.chomp     # Read one line from the client\n  puts "Received: #{data}"\n  client.puts "You said: #{data}"  # Echo back\n  client.close\nend\n'})}),"\n",(0,s.jsx)(t.p,{children:"This example runs in a loop, handling one client at a time. For concurrent clients, consider forking or threading for each connection."})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},65404:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>o});var r=n(36672);const s={},i=r.createContext(s);function c(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);