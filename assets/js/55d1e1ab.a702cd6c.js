"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[52843],{28738:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>g,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"ruby/logging/expert/structured_json_logging","title":"structured_json_logging","description":"\ud83d\udd27 Structured JSON Logging with Custom Formatter","source":"@site/docs/ruby/logging/expert/structured_json_logging.md","sourceDirName":"ruby/logging/expert","slug":"/ruby/logging/expert/structured_json_logging","permalink":"/keep-being-human-dev/docs/ruby/logging/expert/structured_json_logging","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/logging/expert/structured_json_logging.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"correlation_id_propagation","permalink":"/keep-being-human-dev/docs/ruby/logging/expert/correlation_id_propagation"},"next":{"title":"custom_logger_formatter","permalink":"/keep-being-human-dev/docs/ruby/logging/middle/custom_logger_formatter"}}');var o=r(23420),s=r(65404);const i={},g=void 0,a={},u=[{value:"\ud83d\udd27 Structured JSON Logging with Custom Formatter",id:"-structured-json-logging-with-custom-formatter",level:2}];function c(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"-structured-json-logging-with-custom-formatter",children:"\ud83d\udd27 Structured JSON Logging with Custom Formatter"}),"\n",(0,o.jsx)(t.p,{children:"By implementing a custom JSON formatter you can output structured logs that are easier to query in ELK or Splunk. This tip shows how to subclass Ruby's Logger and inject dynamic metadata into every log record for full context in high\u2011volume distributed systems."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ruby",children:"require 'logger'\nrequire 'json'\n\nclass JsonFormatter < Logger::Formatter\n  def call(severity, timestamp, progname, msg)\n    log = {\n      timestamp: timestamp.utc.iso8601,\n      severity: severity,\n      progname: progname,\n      message: msg.is_a?(String) ? msg : msg.inspect\n    }\n    # Inject dynamic context if available\n    if Thread.current[:log_context]\n      log.merge!(Thread.current[:log_context])\n    end\n    JSON.generate(log) + \"\\n\"\n  end\nend\n\nlogger = Logger.new(STDOUT)\nlogger.formatter = JsonFormatter.new\n\n# Usage with dynamic context\ndef process_order(order_id)\n  Thread.current[:log_context] = { order_id: order_id, service: 'payment' }\n  logger.info(\"Order processing started\")\nend\n"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},65404:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>g});var n=r(36672);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function g(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);