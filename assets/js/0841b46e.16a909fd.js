"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[6055],{65404:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>l});var t=n(36672);const o={},r=t.createContext(o);function c(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(r.Provider,{value:s},e.children)}},74280:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>c,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"ruby/sockets/expert/custom_tls_alpn_ocsp","title":"custom_tls_alpn_ocsp","description":"\ud83d\udd12 Custom TLS Handshake with ALPN and OCSP Stapling","source":"@site/docs/ruby/sockets/expert/custom_tls_alpn_ocsp.md","sourceDirName":"ruby/sockets/expert","slug":"/ruby/sockets/expert/custom_tls_alpn_ocsp","permalink":"/keep-being-human-dev/docs/ruby/sockets/expert/custom_tls_alpn_ocsp","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/sockets/expert/custom_tls_alpn_ocsp.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"udp_socket_basics","permalink":"/keep-being-human-dev/docs/ruby/sockets/beginner/udp_socket_basics"},"next":{"title":"fiber_scheduler_socket_server","permalink":"/keep-being-human-dev/docs/ruby/sockets/expert/fiber_scheduler_socket_server"}}');var o=n(23420),r=n(65404);const c={},l=void 0,a={},p=[{value:"\ud83d\udd12 Custom TLS Handshake with ALPN and OCSP Stapling",id:"-custom-tls-handshake-with-alpn-and-ocsp-stapling",level:2}];function i(e){const s={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h2,{id:"-custom-tls-handshake-with-alpn-and-ocsp-stapling",children:"\ud83d\udd12 Custom TLS Handshake with ALPN and OCSP Stapling"}),"\n",(0,o.jsx)(s.p,{children:"For enterprise-grade servers, you might need to control ALPN protocols, SNI routing, and OCSP stapling manually. Ruby\u2019s OpenSSL bindings expose low\u2010level hooks to customize the TLS handshake."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-ruby",children:"require 'socket'\nrequire 'openssl'\n\n# Prepare SSL context\nctx = OpenSSL::SSL::SSLContext.new\nctx.ssl_version = :TLSv1_3\nctx.min_version = OpenSSL::SSL::TLS1_2_VERSION\nctx.ciphers = 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'\n\n# Enable ALPN for HTTP/2 and HTTP/1.1\nctx.alpn_protocols = ['h2', 'http/1.1']\nctx.alpn_select_cb = proc do |protocols|\n  # Prefer HTTP/2 if offered\n  (['h2'] & protocols).first || 'http/1.1'\nend\n\n# OCSP stapling callback\nctx.status_request_cb = proc do |ssl|\n  ocsp_resp = File.binread('ocsp_response.der')\n  ocsp_resp\nend\n\n# Load certificates and key\nctx.cert = OpenSSL::X509::Certificate.new(File.read('server.crt'))\nctx.key = OpenSSL::PKey::EC.new(File.read('server.key'))\n\nserver = TCPServer.new(443)\nssl_server = OpenSSL::SSL::SSLServer.new(server, ctx)\n\nloop do\n  ssl_socket = ssl_server.accept\n  selected_proto = ssl_socket.alpn_protocol\n  puts \"Client negotiated: #{selected_proto}\"\n  ssl_socket.write \"Hello over #{selected_proto}!\"\n  ssl_socket.close\nend\n"})}),"\n",(0,o.jsx)(s.p,{children:"Key points:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"alpn_select_cb"})," lets you pick the best protocol based on client offers."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"status_request_cb"})," allows dynamic stapling of OCSP responses per connection."]}),"\n",(0,o.jsx)(s.li,{children:"Always load your cert chain and key securely (e.g., from encrypted storage)."}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(i,{...e})}):i(e)}}}]);