"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[9776],{1561:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"ruby/symbols/advanced/symbol_dynamic_memoization","title":"symbol_dynamic_memoization","description":"\ud83d\udd27 Dynamic Memoization with Symbols and Instance Variables","source":"@site/docs/ruby/symbols/advanced/symbol_dynamic_memoization.md","sourceDirName":"ruby/symbols/advanced","slug":"/ruby/symbols/advanced/symbol_dynamic_memoization","permalink":"/keep-being-human-dev/docs/ruby/symbols/advanced/symbol_dynamic_memoization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/symbols/advanced/symbol_dynamic_memoization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"string_slicing_ranges","permalink":"/keep-being-human-dev/docs/ruby/strings/middle/string_slicing_ranges"},"next":{"title":"symbol_pattern_matching","permalink":"/keep-being-human-dev/docs/ruby/symbols/advanced/symbol_pattern_matching"}}');var s=a(23420),i=a(65404);const o={},c=void 0,r={},m=[{value:"\ud83d\udd27 Dynamic Memoization with Symbols and Instance Variables",id:"-dynamic-memoization-with-symbols-and-instance-variables",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"-dynamic-memoization-with-symbols-and-instance-variables",children:"\ud83d\udd27 Dynamic Memoization with Symbols and Instance Variables"}),"\n",(0,s.jsxs)(n.p,{children:["For expensive computations across multiple methods, use a list of symbols and ",(0,s.jsx)(n.code,{children:"define_method"})," to build memoized accessors dynamically. By constructing instance\u2011variable names from symbols, you can lazily compute and cache values without rewriting boilerplate for each method. This pattern keeps your class definitions DRY and ensures per\u2011instance caching."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class DataFetcher\n  MEMOIZED = %i[user_count post_count comment_count]\n\n  MEMOIZED.each do |name|\n    ivar = "@#{name}".to_sym\n    define_method(name) do\n      if instance_variable_defined?(ivar)\n        instance_variable_get(ivar)\n      else\n        result = send("compute_#{name}")\n        instance_variable_set(ivar, result)\n      end\n    end\n  end\n\n  private\n\n  def compute_user_count\n    # heavy DB query or external API call\u2026\n  end\n\n  # define compute_post_count, compute_comment_count\u2026\nend\n'})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},65404:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>c});var t=a(36672);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);