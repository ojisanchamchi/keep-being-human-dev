"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[19694],{65404:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>o});var n=a(36672);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}},67569:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"rails/authentication_and_authorization/expert/mfa_custom_warden_strategy","title":"mfa_custom_warden_strategy","description":"\ud83d\udd12 Implement Multi-Factor Authentication with a Custom Warden Strategy","source":"@site/docs/rails/authentication_and_authorization/expert/mfa_custom_warden_strategy.md","sourceDirName":"rails/authentication_and_authorization/expert","slug":"/rails/authentication_and_authorization/expert/mfa_custom_warden_strategy","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/expert/mfa_custom_warden_strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/authentication_and_authorization/expert/mfa_custom_warden_strategy.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"graphql_jwt_pundit_integration","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/expert/graphql_jwt_pundit_integration"},"next":{"title":"customize_redirects","permalink":"/keep-being-human-dev/docs/rails/authentication_and_authorization/middle/customize_redirects"}}');var i=a(23420),r=a(65404);const s={},o=void 0,u={},c=[{value:"\ud83d\udd12 Implement Multi-Factor Authentication with a Custom Warden Strategy",id:"-implement-multi-factor-authentication-with-a-custom-warden-strategy",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"-implement-multi-factor-authentication-with-a-custom-warden-strategy",children:"\ud83d\udd12 Implement Multi-Factor Authentication with a Custom Warden Strategy"}),"\n",(0,i.jsxs)(t.p,{children:["Adding a second authentication factor at the Warden layer lets you enforce 2FA at the lowest possible point and fail early. You can define a custom strategy that checks a one-time password (OTP) after Devise\u2019s primary authentication, then inject it into ",(0,i.jsx)(t.code,{children:"Devise.warden"}),". This ensures your entire app benefits from the same flow without polluting controllers."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"# config/initializers/warden.rb\nRails.application.config.middleware.use Warden::Manager do |manager|\n  manager.default_strategies scope: :user, strategies: [:database_authenticatable, :otp_authenticatable]\n  manager.failure_app = Devise::FailureApp\nend\n\nWarden::Strategies.add(:otp_authenticatable) do\n  def valid?\n    params['user'] && params['user']['otp_code']\n  end\n\n  def authenticate!\n    user = User.find_by(email: params['user']['email'])\n    return fail! unless user&.valid_password?(params['user']['password'])\n\n    if user.validate_and_consume_otp!(params['user']['otp_code'])\n      success!(user)\n    else\n      fail!('Invalid OTP code')\n    end\n  end\nend\n"})}),"\n",(0,i.jsx)(t.p,{children:"Then in your Devise sessions controller, prompt for OTP on the second step, verifying via the above strategy. This approach cleanly composes with Devise\u2019s pipeline and ensures uniform failure handling."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);