"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[52637],{65404:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(36672);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},79093:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"rails/routing/expert/api_versioning_constraint","title":"api_versioning_constraint","description":"\ud83d\ude80 API Versioning with Custom Constraint","source":"@site/docs/rails/routing/expert/api_versioning_constraint.md","sourceDirName":"rails/routing/expert","slug":"/rails/routing/expert/api_versioning_constraint","permalink":"/keep-being-human-dev/docs/rails/routing/expert/api_versioning_constraint","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/routing/expert/api_versioning_constraint.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"advanced_route_globbing","permalink":"/keep-being-human-dev/docs/rails/routing/expert/advanced_route_globbing"},"next":{"title":"dynamic_db_driven_routes","permalink":"/keep-being-human-dev/docs/rails/routing/expert/dynamic_db_driven_routes"}}');var o=t(23420),r=t(65404);const s={},a=void 0,c={},u=[{value:"\ud83d\ude80 API Versioning with Custom Constraint",id:"-api-versioning-with-custom-constraint",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"-api-versioning-with-custom-constraint",children:"\ud83d\ude80 API Versioning with Custom Constraint"}),"\n",(0,o.jsx)(n.p,{children:"When you need multiple API versions coexisting in the same Rails app, a custom constraint class gives you full control over the request matching logic. You can inspect headers, query params, or subdomains to route requests to the correct versioned controller without polluting your controllers with version checks."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ruby",children:"# lib/api_version_constraint.rb\nclass ApiVersionConstraint\n  def initialize(options)\n    @version = options[:version]\n    @default = options.fetch(:default, false)\n  end\n\n  def matches?(request)\n    header = request.headers['Accept']\n    has_version = header && header.include?(\"application/vnd.myapp.v#{@version}+json\")\n    @default || has_version\n  end\nend\n\n# config/routes.rb\nRails.application.routes.draw do\n  scope module: 'api' do\n    scope module: 'v1', constraints: ApiVersionConstraint.new(version: 1, default: true) do\n      resources :users\n    end\n\n    scope module: 'v2', constraints: ApiVersionConstraint.new(version: 2) do\n      resources :users, only: [:index, :show]\n    end\n  end\nend\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);