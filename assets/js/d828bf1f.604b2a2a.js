"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[76028],{2732:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"rails/deployment/advanced/puma_phased_restarts","title":"puma_phased_restarts","description":"\ud83d\ude80 Zero-Downtime Deploys with Puma Phased Restarts","source":"@site/docs/rails/deployment/advanced/puma_phased_restarts.md","sourceDirName":"rails/deployment/advanced","slug":"/rails/deployment/advanced/puma_phased_restarts","permalink":"/keep-being-human-dev/docs/rails/deployment/advanced/puma_phased_restarts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rails/deployment/advanced/puma_phased_restarts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"k8s_canary_deployment","permalink":"/keep-being-human-dev/docs/rails/deployment/advanced/k8s_canary_deployment"},"next":{"title":"basic_capistrano_setup","permalink":"/keep-being-human-dev/docs/rails/deployment/beginner/basic_capistrano_setup"}}');var a=t(23420),r=t(65404);const o={},d=void 0,i={},p=[{value:"\ud83d\ude80 Zero-Downtime Deploys with Puma Phased Restarts",id:"-zero-downtime-deploys-with-puma-phased-restarts",level:2}];function c(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"-zero-downtime-deploys-with-puma-phased-restarts",children:"\ud83d\ude80 Zero-Downtime Deploys with Puma Phased Restarts"}),"\n",(0,a.jsxs)(n.p,{children:["When you need to push code without dropping connections, Puma\u2019s phased restart feature lets you reload your Rails app in place. By integrating this with Capistrano, you can perform a ",(0,a.jsx)(n.code,{children:"phased-restart"})," during your deploy, ensuring new worker processes boot with fresh code while old ones finish serving existing requests."]}),"\n",(0,a.jsxs)(n.p,{children:["In your ",(0,a.jsx)(n.code,{children:"config/puma.rb"}),", enable phased restarts:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# config/puma.rb\nworkers Integer(ENV['WEB_CONCURRENCY'] || 2)\nthreads_count = Integer(ENV['MAX_THREADS'] || 5)\nthreads threads_count, threads_count\n\npreload_app!\n\non_worker_boot do\n  ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\nend\n\n# allow phased restarts\nplugin :tmp_restart\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then add a Capistrano task to call it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# lib/capistrano/tasks/puma_phased.rake\nnamespace :puma do\n  desc 'Phased restart Puma'\n  task :phased_restart do\n    on roles(:app) do\n      execute :bundle, :exec, :pumactl, '-S', shared_path.join('tmp/pids/puma.state'), 'phased-restart'\n    end\n  end\nend\n\nafter 'deploy:publishing', 'puma:phased_restart'\n"})}),"\n",(0,a.jsx)(n.p,{children:"This setup triggers Puma to spin up new workers with the updated code while letting existing workers drain connections gracefully."})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var s=t(36672);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);