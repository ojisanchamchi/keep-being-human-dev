"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[57431],{6538:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"ruby/openssl/advanced/smime_sign_and_encrypt","title":"smime_sign_and_encrypt","description":"\u2709\ufe0f S/MIME Signing and Encryption with OpenSSL","source":"@site/docs/ruby/openssl/advanced/smime_sign_and_encrypt.md","sourceDirName":"ruby/openssl/advanced","slug":"/ruby/openssl/advanced/smime_sign_and_encrypt","permalink":"/keep-being-human-dev/docs/ruby/openssl/advanced/smime_sign_and_encrypt","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/openssl/advanced/smime_sign_and_encrypt.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ocsp_certificate_revocation_checking","permalink":"/keep-being-human-dev/docs/ruby/openssl/advanced/ocsp_certificate_revocation_checking"},"next":{"title":"aes_encrypt_decrypt","permalink":"/keep-being-human-dev/docs/ruby/openssl/beginner/aes_encrypt_decrypt"}}');var s=t(23420),r=t(65404);const a={},c=void 0,d={},p=[{value:"\u2709\ufe0f S/MIME Signing and Encryption with OpenSSL",id:"\ufe0f-smime-signing-and-encryption-with-openssl",level:2}];function o(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"\ufe0f-smime-signing-and-encryption-with-openssl",children:"\u2709\ufe0f S/MIME Signing and Encryption with OpenSSL"}),"\n",(0,s.jsx)(n.p,{children:"Use Ruby\u2019s OpenSSL bindings to produce and verify S/MIME messages, providing end\u2011to\u2011end confidentiality and authenticity for email or data streams. This tip shows how to sign, encrypt, then decrypt and verify in a single script\u2014ideal for secure messaging pipelines or automated archival."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"require 'openssl'\n\n# Load keys and certificates\nsign_cert = OpenSSL::X509::Certificate.new(File.read('signer.crt'))\nsign_key  = OpenSSL::PKey::RSA.new(File.read('signer.key'))\nencrypt_cert = OpenSSL::X509::Certificate.new(File.read('recipient.crt'))\n\n# Original data\ndata = 'Top secret payload'\n\n# Sign the data\nsmime = OpenSSL::PKCS7.sign(sign_cert, sign_key, data, [], OpenSSL::PKCS7::DETACHED)\n\n# Encrypt the signed blob\nencrypted = OpenSSL::PKCS7.encrypt([encrypt_cert], smime.to_der,\n                                   OpenSSL::Cipher.new('aes-256-cbc'),\n                                   OpenSSL::PKCS7::BINARY)\n\n# Serialize to PEM\nFile.write('message.pem', encrypted.to_pem)\n\n# --- On the recipient side ---\nmsg = OpenSSL::PKCS7.read_smime(File.read('message.pem'))\n# Decrypt and verify\ndecrypted = OpenSSL::PKCS7.decrypt(msg, sign_key, sign_cert)\nputs \"Verified and decrypted: #{decrypted}\"\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(36672);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);