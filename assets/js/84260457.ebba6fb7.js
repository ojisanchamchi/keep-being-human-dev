"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[95491],{65404:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>t});var s=o(36672);const c={},i=s.createContext(c);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},98753:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"gems/pundit/advanced/dynamic_policy_scopes","title":"dynamic_policy_scopes","description":"\ud83d\udd04 Dynamic Policy Scopes for Role-Based Query Optimization","source":"@site/docs/gems/pundit/advanced/dynamic_policy_scopes.md","sourceDirName":"gems/pundit/advanced","slug":"/gems/pundit/advanced/dynamic_policy_scopes","permalink":"/keep-being-human-dev/docs/gems/pundit/advanced/dynamic_policy_scopes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/pundit/advanced/dynamic_policy_scopes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"optimize_and_compress","permalink":"/keep-being-human-dev/docs/gems/mini_magick/middle/optimize_and_compress"},"next":{"title":"graphql_field_authorization","permalink":"/keep-being-human-dev/docs/gems/pundit/advanced/graphql_field_authorization"}}');var c=o(23420),i=o(65404);const a={},t=void 0,r={},d=[{value:"\ud83d\udd04 Dynamic Policy Scopes for Role-Based Query Optimization",id:"-dynamic-policy-scopes-for-role-based-query-optimization",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"-dynamic-policy-scopes-for-role-based-query-optimization",children:"\ud83d\udd04 Dynamic Policy Scopes for Role-Based Query Optimization"}),"\n",(0,c.jsxs)(n.p,{children:["When you have complex multi\u2011tenant or role\u2011based access, you can build dynamic scopes by chaining sub\u2011scopes and leveraging metaprogramming. This approach avoids duplicating ",(0,c.jsx)(n.code,{children:"resolve"})," logic for each role and keeps your database queries efficient."]}),"\n",(0,c.jsxs)(n.p,{children:["First, define individual sub\u2011scopes on your policy's ",(0,c.jsx)(n.code,{children:"Scope"})," class:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ruby",children:"class ProjectPolicy < ApplicationPolicy\n  class Scope < Scope\n    def resolve\n      base = Pundit.policy_scope!(user, base_record)\n      chain_scopes(base)\n    end\n\n    private\n\n    def chain_scopes(scope)\n      scopes = []\n      scopes << scope.where(organization_id: user.organization_id)\n      scopes << scope.where(public: true) if user.guest?\n      scopes << scope.all if user.admin?\n\n      # Combine all scopes using OR\n      scopes.reduce { |combined, s| combined.or(s) }\n    end\n  end\nend\n"})}),"\n",(0,c.jsx)(n.p,{children:"Then call it in your controller to fetch only authorized projects:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ruby",children:"class ProjectsController < ApplicationController\n  def index\n    @projects = policy_scope(Project)\n  end\nend\n"})}),"\n",(0,c.jsxs)(n.p,{children:["This pattern scales when you add new roles or sub\u2011scopes\u2014just add methods in ",(0,c.jsx)(n.code,{children:"chain_scopes"})," without touching the controller."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(p,{...e})}):p(e)}}}]);