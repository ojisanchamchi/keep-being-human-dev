"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[42328],{61982:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>l,frontMatter:()=>u,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"ruby/concurrency_and_mutexes/middle/mutex_try_lock","title":"mutex_try_lock","description":"\u23f1\ufe0f Non\u2011Blocking Lock with Mutex#try_lock","source":"@site/docs/ruby/concurrency_and_mutexes/middle/mutex_try_lock.md","sourceDirName":"ruby/concurrency_and_mutexes/middle","slug":"/ruby/concurrency_and_mutexes/middle/mutex_try_lock","permalink":"/keep-being-human-dev/docs/ruby/concurrency_and_mutexes/middle/mutex_try_lock","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/concurrency_and_mutexes/middle/mutex_try_lock.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"mutex_synchronize","permalink":"/keep-being-human-dev/docs/ruby/concurrency_and_mutexes/middle/mutex_synchronize"},"next":{"title":"autoload_with_const_missing","permalink":"/keep-being-human-dev/docs/ruby/constants/advanced/autoload_with_const_missing"}}');var r=t(23420),c=t(65404);const u={},s=void 0,i={},a=[{value:"\u23f1\ufe0f Non\u2011Blocking Lock with Mutex#try_lock",id:"\ufe0f-nonblocking-lock-with-mutextry_lock",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"\ufe0f-nonblocking-lock-with-mutextry_lock",children:"\u23f1\ufe0f Non\u2011Blocking Lock with Mutex#try_lock"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"Mutex#try_lock"})," when you want to attempt acquiring the lock without blocking the current thread. If the lock is unavailable, you can perform an alternative action or retry later, improving responsiveness in concurrent systems."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:'require \'thread\'\nmutex = Mutex.new\n\ndef work(mutex)\n  if mutex.try_lock\n    begin\n      puts "#{Thread.current.object_id}: Got the lock!"\n      sleep(0.1)\n    ensure\n      mutex.unlock\n    end\n  else\n    puts "#{Thread.current.object_id}: Could not get the lock, doing something else"\n  end\nend\n\nthreads = 5.times.map { Thread.new { 10.times { work(mutex) } } }\nthreads.each(&:join)\n'})})]})}function l(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>u,x:()=>s});var o=t(36672);const r={},c=o.createContext(r);function u(e){const n=o.useContext(c);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:u(e.components),o.createElement(c.Provider,{value:n},e.children)}}}]);