"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[89011],{20519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"ruby/openssl/advanced/ocsp_certificate_revocation_checking","title":"ocsp_certificate_revocation_checking","description":"\ud83d\udd0d OCSP Revocation Checking in Ruby","source":"@site/docs/ruby/openssl/advanced/ocsp_certificate_revocation_checking.md","sourceDirName":"ruby/openssl/advanced","slug":"/ruby/openssl/advanced/ocsp_certificate_revocation_checking","permalink":"/keep-being-human-dev/docs/ruby/openssl/advanced/ocsp_certificate_revocation_checking","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/openssl/advanced/ocsp_certificate_revocation_checking.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"custom_ssl_context_configuration","permalink":"/keep-being-human-dev/docs/ruby/openssl/advanced/custom_ssl_context_configuration"},"next":{"title":"smime_sign_and_encrypt","permalink":"/keep-being-human-dev/docs/ruby/openssl/advanced/smime_sign_and_encrypt"}}');var r=t(23420),c=t(65404);const o={},i=void 0,a={},u=[{value:"\ud83d\udd0d OCSP Revocation Checking in Ruby",id:"-ocsp-revocation-checking-in-ruby",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"-ocsp-revocation-checking-in-ruby",children:"\ud83d\udd0d OCSP Revocation Checking in Ruby"}),"\n",(0,r.jsx)(n.p,{children:"Rather than relying solely on CRLs, you can perform on\u2011the\u2011fly OCSP queries to the issuer\u2019s responder to verify a certificate\u2019s revocation status. This is crucial for systems requiring real\u2011time assurance of peer identities. Ruby lets you craft and parse OCSP requests, then integrate results into your SSLContext handshake or custom validation logic."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"require 'openssl'\n\ncert = OpenSSL::X509::Certificate.new(File.read('peer.crt'))\nissuer = OpenSSL::X509::Certificate.new(File.read('issuer.crt'))\nocsp_uri = cert.extensions.detect { |e| e.oid == 'authorityInfoAccess' }\n  .value[/OCSP - URI:(\\S+)/, 1]\n\n# Build OCSP request\nrequest = OpenSSL::OCSP::Request.new\nrequest.add_cert(cert, issuer, OpenSSL::Digest::SHA1.new)\n\n# Send via HTTP\nhttp = Net::HTTP.new(URI(ocsp_uri).host)\nresp = http.post(URI(ocsp_uri).request_uri, request.to_der,\n                 'Content-Type' => 'application/ocsp-request')\n\n# Parse and interpret response\nocsp_resp = OpenSSL::OCSP::Response.new(resp.body)\nstatus = ocsp_resp.basic_status.first.status\nputs status == OpenSSL::OCSP::V_OK ? 'Certificate is good' : 'Revoked or unknown'\n"})})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(36672);const r={},c=s.createContext(r);function o(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);