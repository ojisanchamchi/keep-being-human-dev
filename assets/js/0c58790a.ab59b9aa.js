"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[62338],{11548:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"ruby/profiling/advanced/tracepoint_custom_profile","title":"tracepoint_custom_profile","description":"\ud83d\udd75\ufe0f Custom Event Profiling with TracePoint","source":"@site/docs/ruby/profiling/advanced/tracepoint_custom_profile.md","sourceDirName":"ruby/profiling/advanced","slug":"/ruby/profiling/advanced/tracepoint_custom_profile","permalink":"/keep-being-human-dev/docs/ruby/profiling/advanced/tracepoint_custom_profile","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/profiling/advanced/tracepoint_custom_profile.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"stackprof_sampling_mode","permalink":"/keep-being-human-dev/docs/ruby/profiling/advanced/stackprof_sampling_mode"},"next":{"title":"benchmark_bm","permalink":"/keep-being-human-dev/docs/ruby/profiling/beginner/benchmark_bm"}}');var i=t(23420),r=t(65404);const a={},c=void 0,s={},l=[{value:"\ud83d\udd75\ufe0f Custom Event Profiling with TracePoint",id:"\ufe0f-custom-event-profiling-with-tracepoint",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"\ufe0f-custom-event-profiling-with-tracepoint",children:"\ud83d\udd75\ufe0f Custom Event Profiling with TracePoint"}),"\n",(0,i.jsx)(n.p,{children:"When you need fine-grained insight beyond CPU timing\u2014like tracking allocations or GC events\u2014TracePoint allows hooking into Ruby\u2019s VM events. You can build custom profilers that collect metrics on calls, returns, class definitions, or object allocations."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'trace = TracePoint.new(:call, :return, :allocations) do |tp|\n  case tp.event\n  when :call\n    puts "Calling: #{tp.defined_class}##{tp.method_id} at #{tp.path}:#{tp.lineno}"\n  when :allocations\n    puts "Allocated: #{tp.self.class} at #{tp.path}:#{tp.lineno}"\n  end\nend\n\ntrace.enable\n# Run the code segment you want to inspect\ndo_complex_task\ntrace.disable\n'})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},65404:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(36672);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);