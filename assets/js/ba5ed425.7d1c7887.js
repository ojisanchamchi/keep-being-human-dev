"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[56533],{65404:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var o=t(36672);const c={},s=o.createContext(c);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},79194:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"ruby/networking/advanced/nonblocking_tcp_socket","title":"nonblocking_tcp_socket","description":"\ud83d\ude80 Non-Blocking TCP Sockets with IO.select","source":"@site/docs/ruby/networking/advanced/nonblocking_tcp_socket.md","sourceDirName":"ruby/networking/advanced","slug":"/ruby/networking/advanced/nonblocking_tcp_socket","permalink":"/keep-being-human-dev/docs/ruby/networking/advanced/nonblocking_tcp_socket","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/networking/advanced/nonblocking_tcp_socket.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"http2_stream_multiplexing","permalink":"/keep-being-human-dev/docs/ruby/networking/advanced/http2_stream_multiplexing"},"next":{"title":"http_get_request","permalink":"/keep-being-human-dev/docs/ruby/networking/beginner/http_get_request"}}');var c=t(23420),s=t(65404);const r={},i=void 0,a={},d=[{value:"\ud83d\ude80 Non-Blocking TCP Sockets with IO.select",id:"-non-blocking-tcp-sockets-with-ioselect",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h2,{id:"-non-blocking-tcp-sockets-with-ioselect",children:"\ud83d\ude80 Non-Blocking TCP Sockets with IO.select"}),"\n",(0,c.jsxs)(n.p,{children:["By using ",(0,c.jsx)(n.code,{children:"Socket#connect_nonblock"})," and ",(0,c.jsx)(n.code,{children:"IO.select"}),", you can manage dozens of concurrent connections without threads. This approach avoids blocking on connect/send calls and lets you handle readiness manually, improving throughput for high-load scenarios. Handle ",(0,c.jsx)(n.code,{children:"Errno::EINPROGRESS"})," and use ",(0,c.jsx)(n.code,{children:"IO.select"})," to wait for writable/readable sockets before proceeding."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ruby",children:"require 'socket'\n\naddr = Socket.sockaddr_in(80, 'example.com')\nsock = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)\n\nbegin\n  sock.connect_nonblock(addr)\nrescue IO::WaitWritable\n  # Wait until socket is writable (connected)\n  IO.select(nil, [sock], nil, 5) or raise \"Connection timeout\"\nend\n\n# Send data non-blocking\nrequest = \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\nConnection: close\\r\\n\\r\\n\"\nsock.send_nonblock(request)\n\n# Read response when readable\nwhile IO.select([sock], nil, nil, 5)\n  chunk = sock.recv_nonblock(1024)\n  puts chunk\nend\n\nsock.close\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}}}]);