"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[17414],{65404:(e,s,t)=>{t.d(s,{R:()=>n,x:()=>o});var c=t(36672);const r={},a=c.createContext(r);function n(e){const s=c.useContext(a);return c.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),c.createElement(a.Provider,{value:s},e.children)}},82528:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>i,contentTitle:()=>o,default:()=>p,frontMatter:()=>n,metadata:()=>c,toc:()=>d});const c=JSON.parse('{"id":"gems/rspec/custom_matchers/advanced/parameterized_block_matchers","title":"parameterized_block_matchers","description":"\u26a1 Parameterized Matchers with supportsblockexpectations","source":"@site/docs/gems/rspec/custom_matchers/advanced/parameterized_block_matchers.md","sourceDirName":"gems/rspec/custom_matchers/advanced","slug":"/gems/rspec/custom_matchers/advanced/parameterized_block_matchers","permalink":"/keep-being-human-dev/docs/gems/rspec/custom_matchers/advanced/parameterized_block_matchers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/rspec/custom_matchers/advanced/parameterized_block_matchers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"diffable_custom_matchers","permalink":"/keep-being-human-dev/docs/gems/rspec/custom_matchers/advanced/diffable_custom_matchers"},"next":{"title":"basic_custom_matcher","permalink":"/keep-being-human-dev/docs/gems/rspec/custom_matchers/beginner/basic_custom_matcher"}}');var r=t(23420),a=t(65404);const n={},o=void 0,i={},d=[{value:"\u26a1 Parameterized Matchers with supports_block_expectations",id:"-parameterized-matchers-with-supports_block_expectations",level:2}];function m(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h2,{id:"-parameterized-matchers-with-supports_block_expectations",children:"\u26a1 Parameterized Matchers with supports_block_expectations"}),"\n",(0,r.jsxs)(s.p,{children:["Custom block matchers let you test behavior around blocks or procs and accept parameters. By declaring ",(0,r.jsx)(s.code,{children:"supports_block_expectations"}),", you allow ",(0,r.jsx)(s.code,{children:"expect { \u2026 }"})," syntax and can pass arguments into your matcher for dynamic assertions."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:'# spec/support/matchers/yield_successfully_with.rb\nRSpec::Matchers.define :yield_successfully_with do |*args|\n  supports_block_expectations\n\n  match do |actual_block|\n    begin\n      actual_block.call(*args)\n      true\n    rescue => e\n      @error = e\n      false\n    end\n  end\n\n  failure_message do\n    "expected block to yield successfully with #{args.inspect}, but it raised #{@error.class}: #{@error.message}"\n  end\nend\n'})}),"\n",(0,r.jsx)(s.p,{children:"Usage:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"expect { |b| perform_async_task(5, &b) }.to yield_successfully_with(5)\n"})})]})}function p(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}}}]);