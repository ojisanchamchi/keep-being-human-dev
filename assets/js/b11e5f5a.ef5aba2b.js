"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[73441],{65404:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var n=s(36672);const r={},a=n.createContext(r);function i(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:t},e.children)}},92504:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"gems/sidekiq/advanced/batch_orchestration","title":"batch_orchestration","description":"\ud83d\uddc2\ufe0f Orchestrating Jobs with Sidekiq Batches","source":"@site/docs/gems/sidekiq/advanced/batch_orchestration.md","sourceDirName":"gems/sidekiq/advanced","slug":"/gems/sidekiq/advanced/batch_orchestration","permalink":"/keep-being-human-dev/docs/gems/sidekiq/advanced/batch_orchestration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/gems/sidekiq/advanced/batch_orchestration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"streaming_responses","permalink":"/keep-being-human-dev/docs/gems/ruby-openai/middle/streaming_responses"},"next":{"title":"custom_retry_backoff","permalink":"/keep-being-human-dev/docs/gems/sidekiq/advanced/custom_retry_backoff"}}');var r=s(23420),a=s(65404);const i={},o=void 0,c={},d=[{value:"\ud83d\uddc2\ufe0f Orchestrating Jobs with Sidekiq Batches",id:"\ufe0f-orchestrating-jobs-with-sidekiq-batches",level:2}];function h(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"\ufe0f-orchestrating-jobs-with-sidekiq-batches",children:"\ud83d\uddc2\ufe0f Orchestrating Jobs with Sidekiq Batches"}),"\n",(0,r.jsx)(t.p,{children:"Use Sidekiq Pro batches to execute complex, multi\u2011step workflows with success and death callbacks. Batches let you group jobs and define callbacks that run once all jobs in the batch have finished or if any job dies."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ruby",children:"class ReportGenerationService\n  def call(user_id)\n    batch = Sidekiq::Batch.new\n    batch.description = \"Generate reports for user #{user_id}\"\n    batch.on(:complete, ReportCallbacks, { user_id: user_id })\n    batch.on(:death, ReportCallbacks,    { user_id: user_id })\n\n    batch.jobs do\n      # Distribute work across shards\n      5.times { |i| ReportWorker.perform_async(user_id, shard: i) }\n    end\n  end\nend\n\nclass ReportCallbacks\n  def on_complete(status, options)\n    UserMailer.with(id: options['user_id']).reports_ready.deliver_later\n  end\n\n  def on_death(status, options)\n    UserMailer.with(id: options['user_id']).report_failed.deliver_later\n  end\nend\n"})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);