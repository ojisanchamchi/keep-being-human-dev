"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[93626],{65404:(e,n,d)=>{d.d(n,{R:()=>r,x:()=>i});var o=d(36672);const t={},a=o.createContext(t);function r(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(a.Provider,{value:n},e.children)}},68358:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"ruby/metaprogramming/middle/hook_method_added","title":"hook_method_added","description":"\ud83d\udccc Hooking into method_added","source":"@site/docs/ruby/metaprogramming/middle/hook_method_added.md","sourceDirName":"ruby/metaprogramming/middle","slug":"/ruby/metaprogramming/middle/hook_method_added","permalink":"/keep-being-human-dev/docs/ruby/metaprogramming/middle/hook_method_added","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/metaprogramming/middle/hook_method_added.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"fluent_interface_chaining","permalink":"/keep-being-human-dev/docs/ruby/metaprogramming/middle/fluent_interface_chaining"},"next":{"title":"method_missing_fallback","permalink":"/keep-being-human-dev/docs/ruby/metaprogramming/middle/method_missing_fallback"}}');var t=d(23420),a=d(65404);const r={},i=void 0,s={},m=[{value:"\ud83d\udccc Hooking into method_added",id:"-hooking-into-method_added",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"-hooking-into-method_added",children:"\ud83d\udccc Hooking into method_added"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"method_added"})," is a hook called whenever a new instance method is defined. Use it to wrap or annotate methods automatically\u2014for example, adding logging or instrumentation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'module MethodLogger\n  def self.included(base)\n    base.extend ClassMethods\n  end\n\n  module ClassMethods\n    def method_added(name)\n      return if @_adding_wrapper\n      @_adding_wrapper = true\n\n      original = instance_method(name)\n      define_method(name) do |*args, &block|\n        puts "Calling \\#{name} with \\\\#{args.inspect}"\n        original.bind(self).call(*args, &block)\n      end\n\n      @_adding_wrapper = false\n    end\n  end\nend\n\nclass Worker\n  include MethodLogger\n\n  def perform(x)\n    x * 2\n  end\nend\n\nWorker.new.perform(10)\n# Logs: Calling perform with [10]\n'})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);