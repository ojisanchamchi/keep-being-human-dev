"use strict";(self.webpackChunkkeep_being_human_dev=self.webpackChunkkeep_being_human_dev||[]).push([[64179],{65404:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var s=r(36672);const t={},o=s.createContext(t);function d(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(o.Provider,{value:n},e.children)}},78161:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>l,frontMatter:()=>d,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"ruby/classes_and_modules/expert/prepend_method_wrappers","title":"prepend_method_wrappers","description":"\ud83d\udd27 Leveraging Module#prepend for Method Wrapping","source":"@site/docs/ruby/classes_and_modules/expert/prepend_method_wrappers.md","sourceDirName":"ruby/classes_and_modules/expert","slug":"/ruby/classes_and_modules/expert/prepend_method_wrappers","permalink":"/keep-being-human-dev/docs/ruby/classes_and_modules/expert/prepend_method_wrappers","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ruby/classes_and_modules/expert/prepend_method_wrappers.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"namespaces_with_module_nesting","permalink":"/keep-being-human-dev/docs/ruby/classes_and_modules/expert/namespaces_with_module_nesting"},"next":{"title":"proxy_method_missing","permalink":"/keep-being-human-dev/docs/ruby/classes_and_modules/expert/proxy_method_missing"}}');var t=r(23420),o=r(65404);const d={},a=void 0,i={},p=[{value:"\ud83d\udd27 Leveraging <code>Module#prepend</code> for Method Wrapping",id:"-leveraging-moduleprepend-for-method-wrapping",level:2}];function c(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"-leveraging-moduleprepend-for-method-wrapping",children:["\ud83d\udd27 Leveraging ",(0,t.jsx)(n.code,{children:"Module#prepend"})," for Method Wrapping"]}),"\n",(0,t.jsxs)(n.p,{children:["Unlike ",(0,t.jsx)(n.code,{children:"include"}),", ",(0,t.jsx)(n.code,{children:"prepend"})," places your module before the class in the lookup chain, making it ideal for wrapping or overriding methods. Use it to instrument or augment existing behavior without altering the original method definition. This approach is cleaner than alias chaining and preserves method visibility."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'module Logging\n  def save(*args)\n    puts "[LOG] Saving #{self.class} with \\\\u{2026}"\n    super\n  end\nend\n\nclass Record\n  prepend Logging\n  def save\n    # heavy lifting\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Logging#save"})," runs first, then calls the original via ",(0,t.jsx)(n.code,{children:"super"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);